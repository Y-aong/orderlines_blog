---
icon: pen-to-square
date: 2023-07-15
category:
  - python
tag:
  - 多线程
---

# python多线程

### 定义

 操作系统课上我们都学过，进程是资源的分配单位，而线程是CPU调度运行的基本单位。也就是说，即使是多进程程序，调度依然是按照多个线程去进行调度，由于CPU时间片分配给每个独立调度的线程，拥有四个线程的进程比拥有一个线程的进程拥有更多的CPU时间片。如果一个有四个线程的进程运行在一个四核的CPU机器上，那么核的利用率可以达到100%，即所有的核都可以调度运行一个线程， 不会出现一方有难，八方围观的情况。同样，四个单线程进程也能使四核的CPU机器计算资源利用率达到100%，因为每个进程中的线程被独立调度执行。

  当我们被问到python多线程的时候，回答一般都会涉及到GIL，但是GIL其实不是python本身的特性，而是CPython实现时引入的一种机制， 而JPython的实现里面里就没有GIL。

![img](https://ask.qcloudimg.com/draft/6708222/xacmn9mmq9.png)

总结python的多线程不是真正的多线程，不能发挥出计算机中多核的优点，原因是因为，`Cpython`中存在着GIL全局线程锁，同时只可以由一个线程进行运行

### 二、python多线程的实现

```python
# 基于方法

def demo():
    for i in range(10):
        print(i)


t1 = threading.Thread(target=demo)
t1.start()


# 基于类

class Demo(threading.Thread):
    def __init__(self):
        super(Demo, self).__init__()

    def run(self) -> None:
        demo()
```

### 三、线程锁LOCK

线程安全是多线程或多进程编程中的一个概念，在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况

锁是Python提供给我们能够自行操控线程切换的一种手段，使用锁可以让线程的切换变的有序。

一旦线程的切换变的有序后，各个线程之间对数据的访问、修改就变的可控，所以若要保证线程安全，就必须使用锁

#### 锁的分类

- 同步锁：lock（一次只能放行一个）
- 递归锁：rlock（一次只能放行一个）
- 条件锁：condition（一次可以放行任意个）
- 事件锁：event（一次全部放行）
- 信号量锁：semaphore（一次可以放行特定个）



#### 同步锁介绍

|                      方法                      |                             描述                             |
| :--------------------------------------------: | :----------------------------------------------------------: |
|               `threading.Lock`()               |                      返回一个同步锁对象                      |
| `lockObject.acquire`(blocking=True, timeout=1) | 上锁，当一个线程在执行被上锁代码块时，将不允许切换到其他线程运行，默认锁失效时间为1秒 |
|             `lockObject.release`()             | 解锁，当一个线程在执行未被上锁代码块时，将允许系统根据策略自行切换到其他线程中运行 |
|             `lockObject.locaked`()             |         判断该锁对象是否处于上锁状态，返回一个布尔值         |

```python
import threading

num = 1


def add():
    lock.acquire()
    global num
    for i in range(10_000_000):
        num += 1
    lock.release()


def sub():
    lock.acquire()
    global num
    for i in range(10_000_000):
        num -= 1
    lock.release()


if __name__ == "__main__":
    lock = threading.Lock()

    subThread01 = threading.Thread(target=add)
    subThread02 = threading.Thread(target=sub)

    subThread01.start()
    subThread02.start()

    subThread01.join()
    subThread02.join()

    print("num result : %s" % num)

```

#### 死锁

对于同步锁来说，一次acquire()必须对应一次release()，不能出现连续重复使用多次acquire()后再重复使用多次release()的操作，这样会引起死锁造成程序的阻塞，完全不动了，如下所示：

### Event事件

事件锁是基于条件锁来做的，它与条件锁的区别在于一次只能放行全部，不能放行任意个数量的子线程继续运行。

我们可以将事件锁看为红绿灯，当红灯时所有子线程都暂停运行，并进入“等待”状态，当绿灯时所有子线程都恢复“运行”。

|              方法               |                             描述                             |
| :-----------------------------: | :----------------------------------------------------------: |
|       `threading.Event`()       |                      返回一个事件锁对象                      |
|      `lockObject.clear`()       |           将事件锁设为红灯状态，即所有线程暂停运行           |
|      `lockObject.is_set`()      |       用来判断当前事件锁状态，红灯为False，绿灯为True        |
|       `lockObject.set`()        |           将事件锁设为绿灯状态，即所有线程恢复运行           |
| `lockObject.wait`(timeout=None) | 将当前线程设置为“等待”状态，只有该线程接到“绿灯通知”或者超时时间到期之后才会继续运行，在“等待”状态下的线程将允许系统根据策略自行切换到其他线程中运行 |

### 四、线程池

线程池是一种用于减少线程本身创建和销毁造成的开销的技术，属于典型的空间换时间操作。如果应用程序需要频繁的将任务派发到线程中执行，线程池就是必选项，因为创建和释放线程涉及到大量的系统底层操作，开销较大，如果能够在应用程序工作期间，将创建和释放线程的操作变成预创建和借还操作，将大大减少底层开销。线程池在应用程序启动后，立即创建一定数量的线程，放入空闲队列中。这些线程最开始都处于阻塞状态，不会消耗CPU资源，但会占用少量的内存空间。当任务到来后，从队列中取出一个空闲线程，把任务派发到这个线程中运行，并将该线程标记为已占用。当线程池中所有的线程都被占用后，可以选择自动创建一定数量的新线程，用于处理更多的任务，也可以选择让任务排队等待直到有空闲的线程可用。在任务执行完毕后，线程并不退出结束，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程长时间处于闲置状态时，线程池可以自动销毁一部分线程，回收系统资源。基于这种预创建技术，线程池将线程创建和销毁本身所带来的开销分摊到了各个具体的任务上，执行次数越多，每个任务所分担到的线程本身开销则越小。

一般线程池都必须具备下面几个组成部分：

1. 线程池管理器：用于创建并管理线程池。
2. 工作线程和线程队列：线程池中实际执行的线程以及保存这些线程的容器。
3. 任务接口：将线程执行的任务抽象出来，形成任务接口，确保线程池与具体的任务无关。
4. 任务队列：线程池中保存等待被执行的任务的容器。