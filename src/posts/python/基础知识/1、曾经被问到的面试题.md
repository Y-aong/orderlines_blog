---
icon: pen-to-square
date: 2023-07-15
category:
  - python
tag:
  - python面试
---

# python经典面试题



### 一、python中的鸭子对象

一句话概述，看起来像是鸭子，走路像鸭子，叫声像鸭子他就是鸭子

对于代码来说，比如可以iter(obj) == True 就是可迭代对象，str, list，没有`__next__`方法，但是它实现了`__getitem__()`方法，所以也是可迭代对象



### 二、`python3`和`python2`中for * in xx,xx是什么，为什么要改变

**可迭代对象**

具有惰性计算特点的序列称为惰性序列，Python 中的迭代器就是一个惰性序列，调用 iter() 返回一个 iterator 并赋值给一个变量后不会立即进行求值，而是当你用到其中某些元素的时候才去求某元素的值。

惰性计算还可以在大规模数据处理中平滑处理时间，提高内存使用率。当处理大规模数据时，一次性进行处理往往是不方便的。



### 三、python中的深浅拷贝

浅拷贝通常只复制对象本身，而深拷贝不仅会复制对象，还会递归的复制对象所关联的对象。深拷贝可能会遇到两个问题：一是一个对象如果直接或间接的引用了自身，会导致无休止的递归拷贝；二是深拷贝可能对原本设计为多个对象共享的数据也进行拷贝。Python通过`copy`模块中的`copy`和`deepcopy`函数来实现浅拷贝和深拷贝操作，其中`deepcopy`可以通过`memo`字典来保存已经拷贝过的对象，从而避免刚才所说的自引用递归问题；此外，可以通过`copyreg`模块的`pickle`函数来定制指定类型对象的拷贝行为。

`deepcopy`函数的本质其实就是对象的一次序列化和一次返回序列化，面试题中还考过用自定义函数实现对象的深拷贝操作，显然我们可以使用`pickle`模块的`dumps`和`loads`来做到，代码如下所示。

```
import pickle

my_deep_copy = lambda obj: pickle.loads(pickle.dumps(obj))
```

列表的切片操作`[:]`相当于实现了列表对象的浅拷贝，而字典的`copy`方法可以实现字典对象的浅拷贝。对象拷贝其实是更为快捷的创建对象的方式。在Python中，通过构造器创建对象属于两阶段构造，首先是分配内存空间，然后是初始化。在创建对象时，我们也可以基于“原型”对象来创建新对象，通过对原型对象的拷贝（复制内存）就完成了对象的创建和初始化，这种做法更加高效，这也就是设计模式中的原型模式。



### 四、正则表达式的match方法和search方法有什么区别？

`match`方法是从字符串的起始位置进行正则表达式匹配，返回`Match`对象或None。`search`方法会扫描整个字符串来找寻匹配的模式，同样也是返回Match对象或None。



### 五、Python中为什么没有函数重载

首先Python是解释型语言，函数重载现象通常出现在编译型语言中。其次Python是动态类型语言，函数的参数没有类型约束，也就无法根据参数类型来区分重载。再者Python中函数的参数可以有默认值，可以使用可变参数和关键字参数，因此即便没有函数重载，也要可以让一个函数根据调用者传入的参数产生不同的行为。



### 六、python中为什么要引入全局解释器锁

Python引入全局解释器锁（GIL，Global Interpreter Lock）的主要原因是为了**简化Python解释器的设计和实现，并确保解释器内部数据结构在多线程环境下的安全性**。
GIL是Python解释器中的一种机制，它是一把全局锁，用于**保护解释器免受多线程并发访问的影响**。这意味着在Python中，同一时刻只允许一个线程执行Python字节码。
当一个线程执行Python字节码时，其他线程将被阻塞，即使系统具有多个CPU核心，Python的多线程程序也不能同时利用它们。

GIL的引入可以追溯到Python的早期设计。在Python的设计初期，为了简化解释器的实现，并确保多线程环境下的线程安全，设计者决定引入GIL。通过GIL，Python解释器不需要在共享数据上实现复杂的同步机制，从而降低了实现的复杂性。然而，GIL的存在也带来了一些限制和挑战。由于GIL的存在，Python的多线程在CPU密集型任务上并不能提供真正的并行性。这意味着在多核CPU上，Python的多线程程序可能无法充分利用硬件资源。

为了解决这个问题，Python社区已经提出了一些解决方案，如使用多进程（multiprocessing）代替多线程，或者使用支持并行计算的库（如NumPy、SciP等）。 

总之，Python引入GIL是为了简化解释器的设计和实现，并确保多线程环境下的线程安全。然而，这也带来了一些限制和挑战，需要在使用Python多线程时特别注意。



### 七、如何理解异步IO

1. **同步 vs. 异步**：
   - **同步（Synchronous）**：同步操作是指在发起一个操作后，必须等待该操作完成才能继续执行后续的操作。在同步操作中，程序会阻塞（Block）当前线程或进程，直到操作完成。
   - **异步（Asynchronous）**：异步操作是指在发起一个操作后，可以立即返回并继续执行后续的操作，而不必等待该操作完成。在异步操作中，程序不会阻塞当前线程或进程，而是使用回调函数、事件循环等机制来处理操作的结果。
2. **IO操作**：
   - **输入/输出（IO）操作**：指的是与外部设备（例如磁盘、网络等）进行数据交换的操作。在计算机中，IO操作是相对于CPU执行的计算操作而言的。常见的IO操作包括读取文件、发送网络请求、接收网络响应等。
3. **异步IO**：
   - **异步IO（Asynchronous IO）**：指的是在进行IO操作时，不需要等待IO操作完成才能继续执行后续的操作。相反，程序可以继续执行其他任务，而IO操作在后台进行。当IO操作完成时，程序可以通过回调函数、事件通知等方式获取IO操作的结果。

在编程中，异步IO通常与事件循环（Event Loop）结合使用，例如在Python中，使用 `asyncio` 模块来实现异步IO操作。异步IO的优点在**于它可以提高程序的并发性和吞吐量，使程序能够更有效地利用系统资源，从而提高性能**。

总的来说，理解异步IO就是理解在IO操作时，程序如何以非阻塞的方式继续执行其他任务，并在IO操作完成后获取操作结果的过程。



### 八、异步IO和事件循环的关系


在 Python 中，异步IO和事件循环密切相关，它们通常一起使用来实现异步编程。

1. **事件循环（Event Loop）**：
   - 事件循环是一个在程序中运行的循环，它负责处理和调度异步任务（例如IO操作、定时器等）。
   - 在事件循环中，任务被添加到事件队列中，并在适当的时候执行。事件循环负责选择要执行的任务，并确保任务按正确的顺序执行。
   - Python 中常用的事件循环实现是 `asyncio` 模块提供的 `asyncio.EventLoop`。
2. **异步IO（Asynchronous IO）**：
   - 异步IO是一种编程模型，它允许程序在执行IO操作时不阻塞当前线程或进程，而是可以继续执行其他任务。
   - 在Python中，异步IO通常使用 `asyncio` 模块来实现，它提供了异步编程的基础设施，包括异步IO操作、协程等。
3. **关系**：
   - 异步IO依赖于事件循环来调度和执行异步任务。当需要执行一个异步IO操作时，任务会被添加到事件循环的事件队列中，并在事件循环的控制下执行。
   - 事件循环负责管理异步任务的执行顺序、任务的状态和执行过程中的异常处理等。
   - 在事件循环中，异步IO操作通常以协程（Coroutine）的形式表示，而协程是一种可以暂停和恢复执行的函数，适用于异步编程。

简而言之，**事件循环是异步IO编程的基础**，它负责调度和执行异步任务，而**异步IO操作则是在事件循环的管理下执行的**。通过事件循环，异步IO可以实现非阻塞的IO操作，并使程序能够更高效地利用系统资源



