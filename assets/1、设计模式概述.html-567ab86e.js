const e=JSON.parse('{"key":"v-177e9296","path":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0.html","title":"1、设计模式的六大原则","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2023-07-15T00:00:00.000Z","category":["python"],"tag":["设计模式"],"description":"1、设计模式的六大原则 一、设计模式的六大原则 单一职责原则 单一职责原则的定义描述非常简单，也不难理解。 一个类只负责完成一个职责或者功能。也就是说在类的设计中 我们不要设计大而全的类,而是要设计粒度小、功能单一的类。 比如 我们设计一个类里面既包含了用户的一些操作,又包含了支付的一些操作,那这个类的职责就不够单一,应该将该类进行 拆分,拆分成多个功能更加单一的,粒度更细的类. 开放封闭原则 定义：对扩展开放，对修改关闭 对扩展开放和对修改关闭表示当一个类或一个方法有新需求或者需求发生改变时应该采用扩展的方式而不应该采用修改原有 逻辑的方式来实现。因为扩展了新的逻辑如果有问题只会影响新的业务，不会影响老业务；而如果采用修改的方式，很有可 能就会影响到老业务受影响。 优点： 新老逻辑解耦，需求发生改变不会影响老业务的逻辑 改动成本最小，只需要追加新逻辑，不需要改的老逻辑 提供代码的稳定性和可扩展性 里氏替换原则 1 ) 什么是替换 ? 替换的前提是面向对象语言所支持的多态特性，同一个行为具有多个不同表现形式或形态的能力。 以 JDK 的集合框架为例，List接口的定义为有序集合，List接口有多个派生类，比如 大家耳熟能详的 ArrayList, LinkedList。那当某个方法参数或变量是 List接口类型时， 既可以是 ArrayList的实现, 也可以是 LinkedList的实现，这就是替换。 2 ) 什么是与期望行为一致的替换？ 在不了解派生类的情况下，仅通过接口或基类的方法，即可清楚的知道方法的行为，而不管哪种派 生类的实现，都与接口或基类方法的期望行为一致。 不需要关心是哪个类对接口进行了实现,因为不管底层如何实现,最终的结果都会符合接口中关于方法的描述(也就是与接口中方法的期望行为一致). 或者说接口或基类的方法是一种契约，使用方按照这个契约来使用，派生类也按照这个契约来实现。这就是与期望行为一致的替换。 接口隔离原则 定义：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。 接口隔离原则与单一职责原则的区别 接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的： 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建 依赖倒置原则 定义：依赖倒置原则（Dependence Inversion Principle，DIP）是指在设计代码架构时，高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。 依赖倒置原则的好处: 减少类间的耦合性，提高系统的稳定性 . (根据类与类之间的耦合度从弱到强排列：依赖关系、关联关系、 聚合关系、组合关系、泛化关系和实现关系 ) 降低并行开发引起的风险 (两个类之间有依赖关系，只要制定出两者之间的接口（或抽象类）就可以独立开发了) 提高代码的可读性和可维护性 迪米特法则 简单来说迪米特法则想要表达的思想就是: 不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。","head":[["meta",{"property":"og:url","content":"https://y-aong.github.io/orderlines_blog/orderlines_blog/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0.html"}],["meta",{"property":"og:site_name","content":"ORDERLINES"}],["meta",{"property":"og:title","content":"1、设计模式的六大原则"}],["meta",{"property":"og:description","content":"1、设计模式的六大原则 一、设计模式的六大原则 单一职责原则 单一职责原则的定义描述非常简单，也不难理解。 一个类只负责完成一个职责或者功能。也就是说在类的设计中 我们不要设计大而全的类,而是要设计粒度小、功能单一的类。 比如 我们设计一个类里面既包含了用户的一些操作,又包含了支付的一些操作,那这个类的职责就不够单一,应该将该类进行 拆分,拆分成多个功能更加单一的,粒度更细的类. 开放封闭原则 定义：对扩展开放，对修改关闭 对扩展开放和对修改关闭表示当一个类或一个方法有新需求或者需求发生改变时应该采用扩展的方式而不应该采用修改原有 逻辑的方式来实现。因为扩展了新的逻辑如果有问题只会影响新的业务，不会影响老业务；而如果采用修改的方式，很有可 能就会影响到老业务受影响。 优点： 新老逻辑解耦，需求发生改变不会影响老业务的逻辑 改动成本最小，只需要追加新逻辑，不需要改的老逻辑 提供代码的稳定性和可扩展性 里氏替换原则 1 ) 什么是替换 ? 替换的前提是面向对象语言所支持的多态特性，同一个行为具有多个不同表现形式或形态的能力。 以 JDK 的集合框架为例，List接口的定义为有序集合，List接口有多个派生类，比如 大家耳熟能详的 ArrayList, LinkedList。那当某个方法参数或变量是 List接口类型时， 既可以是 ArrayList的实现, 也可以是 LinkedList的实现，这就是替换。 2 ) 什么是与期望行为一致的替换？ 在不了解派生类的情况下，仅通过接口或基类的方法，即可清楚的知道方法的行为，而不管哪种派 生类的实现，都与接口或基类方法的期望行为一致。 不需要关心是哪个类对接口进行了实现,因为不管底层如何实现,最终的结果都会符合接口中关于方法的描述(也就是与接口中方法的期望行为一致). 或者说接口或基类的方法是一种契约，使用方按照这个契约来使用，派生类也按照这个契约来实现。这就是与期望行为一致的替换。 接口隔离原则 定义：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。 接口隔离原则与单一职责原则的区别 接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的： 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建 依赖倒置原则 定义：依赖倒置原则（Dependence Inversion Principle，DIP）是指在设计代码架构时，高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。 依赖倒置原则的好处: 减少类间的耦合性，提高系统的稳定性 . (根据类与类之间的耦合度从弱到强排列：依赖关系、关联关系、 聚合关系、组合关系、泛化关系和实现关系 ) 降低并行开发引起的风险 (两个类之间有依赖关系，只要制定出两者之间的接口（或抽象类）就可以独立开发了) 提高代码的可读性和可维护性 迪米特法则 简单来说迪米特法则想要表达的思想就是: 不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-03-17T09:50:53.000Z"}],["meta",{"property":"article:author","content":"Y-aong"}],["meta",{"property":"article:tag","content":"设计模式"}],["meta",{"property":"article:published_time","content":"2023-07-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-17T09:50:53.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1、设计模式的六大原则\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-07-15T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-17T09:50:53.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Y-aong\\",\\"url\\":\\"https://github.com/Y-aong\\"}]}"]]},"headers":[{"level":3,"title":"一、设计模式的六大原则","slug":"一、设计模式的六大原则","link":"#一、设计模式的六大原则","children":[]},{"level":3,"title":"二、单例模式的作用和意义","slug":"二、单例模式的作用和意义","link":"#二、单例模式的作用和意义","children":[]},{"level":3,"title":"三、工厂模式有哪些，有什么区别","slug":"三、工厂模式有哪些-有什么区别","link":"#三、工厂模式有哪些-有什么区别","children":[]},{"level":3,"title":"四、装饰器和代理模式","slug":"四、装饰器和代理模式","link":"#四、装饰器和代理模式","children":[]}],"git":{"createdTime":1736258707000,"updatedTime":1742205053000,"contributors":[{"name":"Y-aong","email":"1627469727@qq.com","commits":2}]},"readingTime":{"minutes":9.8,"words":2941},"filePathRelative":"posts/设计模式/1、设计模式概述.md","localizedDate":"July 15, 2023","excerpt":"<h1> 1、设计模式的六大原则</h1>\\n<h3> 一、设计模式的六大原则</h3>\\n<ul>\\n<li>\\n<p>单一职责原则</p>\\n<ul>\\n<li>单一职责原则的定义描述非常简单，也不难理解。</li>\\n</ul>\\n<p>一个类只负责完成一个职责或者功能。也就是说在类的设计中 我们不要设计大而全的类,而是要设计粒度小、功能单一的类。</p>\\n<p>比如 我们设计一个类里面既包含了用户的一些操作,又包含了支付的一些操作,那这个类的职责就不够单一,应该将该类进行<br>\\n拆分,拆分成多个功能更加单一的,粒度更细的类.</p>\\n</li>\\n<li>\\n<p>开放封闭原则</p>\\n<ul>\\n<li>定义：对扩展开放，对修改关闭</li>\\n</ul>\\n<p>对扩展开放和对修改关闭表示当一个类或一个方法有新需求或者需求发生改变时应该采用扩展的方式而不应该采用修改原有<br>\\n逻辑的方式来实现。因为扩展了新的逻辑如果有问题只会影响新的业务，不会影响老业务；而如果采用修改的方式，很有可<br>\\n能就会影响到老业务受影响。</p>\\n<p>优点：</p>\\n<ol>\\n<li>新老逻辑解耦，需求发生改变不会影响老业务的逻辑</li>\\n<li>改动成本最小，只需要追加新逻辑，不需要改的老逻辑</li>\\n<li>提供代码的稳定性和可扩展性</li>\\n</ol>\\n</li>\\n<li>\\n<p>里氏替换原则</p>\\n<p>1 ) 什么是替换 ?</p>\\n<p>替换的前提是面向对象语言所支持的多态特性，同一个行为具有多个不同表现形式或形态的能力。</p>\\n<blockquote>\\n<p><strong>以 JDK 的集合框架为例，</strong><code>List</code>接口的定义为有序集合，<code>List</code>接口有多个派生类，比如<br>\\n大家耳熟能详的 <code>ArrayList</code>, <code>LinkedList</code>。那当某个方法参数或变量是 <code>List</code>接口类型时，<br>\\n既可以是 <code>ArrayList</code>的实现, 也可以是 <code>LinkedList</code>的实现，这就是替换。</p>\\n</blockquote>\\n<p>2 ) 什么是与期望行为一致的替换？</p>\\n<p>在不了解派生类的情况下，仅通过接口或基类的方法，即可清楚的知道方法的行为，而不管哪种派<br>\\n生类的实现，都与接口或基类方法的期望行为一致。</p>\\n<blockquote>\\n<p><strong>不需要关心是哪个类对接口进行了实现,因为不管底层如何实现,最终的结果都会符合接口中关于方法的描述(也就是与接口中方法的期望行为一致).</strong></p>\\n<p><strong>或者说接口或基类的方法是一种契约，使用方按照这个契约来使用，派生类也按照这个契约来实现。这就是与期望行为一致的替换。</strong></p>\\n</blockquote>\\n</li>\\n<li>\\n<p>接口隔离原则</p>\\n<p>定义：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p>\\n<p>接口隔离原则与单一职责原则的区别</p>\\n<p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：</p>\\n<ul>\\n<li>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。</li>\\n<li>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建</li>\\n</ul>\\n</li>\\n<li>\\n<p>依赖倒置原则</p>\\n<p>定义：依赖倒置原则（Dependence Inversion Principle，DIP）是指在设计代码架构时，高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p>\\n<p>依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。</p>\\n<p>依赖倒置原则的好处:</p>\\n<ul>\\n<li>减少类间的耦合性，提高系统的稳定性 . (根据类与类之间的耦合度从弱到强排列：依赖关系、关联关系、<br>\\n聚合关系、组合关系、泛化关系和实现关系 )</li>\\n<li>降低并行开发引起的风险 (两个类之间有依赖关系，只要制定出两者之间的接口（或抽象类）就可以独立开发了)</li>\\n<li>提高代码的可读性和可维护性</li>\\n</ul>\\n</li>\\n<li>\\n<p>迪米特法则</p>\\n<p>简单来说迪米特法则想要表达的思想就是: <strong>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。</strong></p>\\n<blockquote>\\n<p><strong>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</strong></p>\\n</blockquote>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
