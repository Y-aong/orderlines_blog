import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as d,e as r}from"./app-2d0f66e1.js";const i={},t=r(`<h1 id="_8、缓存双写一致性" tabindex="-1"><a class="header-anchor" href="#_8、缓存双写一致性" aria-hidden="true">#</a> 8、缓存双写一致性</h1><h3 id="一、基本思路" tabindex="-1"><a class="header-anchor" href="#一、基本思路" aria-hidden="true">#</a> 一、基本思路</h3><p>redis中有数据需要和数据库中的数据一致</p><p>redis中没有数据，数据库中的值要是最终值</p><h3 id="二、canal简介" tabindex="-1"><a class="header-anchor" href="#二、canal简介" aria-hidden="true">#</a> 二、canal简介</h3><h4 id="_1、定义" tabindex="-1"><a class="header-anchor" href="#_1、定义" aria-hidden="true">#</a> 1、定义</h4><p>canal是基于msyql binlog日志的增量订阅和消费的组件</p><h4 id="_2、作用" tabindex="-1"><a class="header-anchor" href="#_2、作用" aria-hidden="true">#</a> 2、作用</h4><ul><li>数据库镜像</li><li>数据库实时备份</li><li>带有业务逻辑的增量数据处理</li></ul><h4 id="_3、工作原理" tabindex="-1"><a class="header-anchor" href="#_3、工作原理" aria-hidden="true">#</a> 3、工作原理</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>canal 工作原理
canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 协议
MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )
canal 解析 binary log 对象(原始为 byte 流)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4、基本操作" tabindex="-1"><a class="header-anchor" href="#_4、基本操作" aria-hidden="true">#</a> 4、基本操作</h4><ul><li>开启mysql的binlog写入功能</li><li>授权cannal连接msyql</li><li>重启mysql</li></ul><h3 id="二-缓存数据的双写一致性探讨" tabindex="-1"><a class="header-anchor" href="#二-缓存数据的双写一致性探讨" aria-hidden="true">#</a> 二，缓存数据的双写一致性探讨</h3><h4 id="_1、目的" tabindex="-1"><a class="header-anchor" href="#_1、目的" aria-hidden="true">#</a> 1、目的</h4><p>要达到缓存数据和mysql数据最终一致</p><h4 id="_2、方案一-、先更新数据库-再更新缓存" tabindex="-1"><a class="header-anchor" href="#_2、方案一-、先更新数据库-再更新缓存" aria-hidden="true">#</a> 2、方案一 、先更新数据库，再更新缓存</h4><p>问题有可能更新缓存失败，造成缓存数据为旧数据，缓存数据和mysql数据不一致</p><h4 id="_3、方案二、先删除缓存-再更新数据库" tabindex="-1"><a class="header-anchor" href="#_3、方案二、先删除缓存-再更新数据库" aria-hidden="true">#</a> 3、方案二、先删除缓存，再更新数据库</h4><p>问题一、缓冲数据和mysql数据不一致</p><p>A线程先删除缓存数据，再去更新mysql，此时来了一个请求B线程，B线程查询缓存没有查到，然后从数据库查询，查询结束将查到的数据写到缓存中，后面再来请求，发生缓存数据和mysql数据不一致，有可能一直脏下去</p><p>总结流程：<br> （1）请求A进行写操作，删除缓存后，工作正在进行中......A还么有彻底更新完<br> （2）请求B开工，查询redis发现缓存不存在<br> （3）请求B继续，去数据库查询得到了myslq中的旧值<br> （4）请求B将旧值写入redis缓存<br> （5）请求A将新值写入mysql数据库<br> 上述情况就会导致不一致的情形出现。</p><table><thead><tr><th>时间</th><th>线程A</th><th>线程B</th><th>出现的问题</th></tr></thead><tbody><tr><td>t1</td><td>请求A进行写操作，删除缓存后，工作正在进行中......</td><td></td><td></td></tr><tr><td>t2</td><td></td><td>1 缓存中读取不到，立刻读mysql，由于A还没有对mysql更新完，读到的是旧值。<br>2 还把从mysql读取的旧值，写回了redis</td><td>1 A还更新完mysql，导致B读到了旧值<br>2 线程B遵守回写机制，把旧值写回redis，导致其它请求读取的还是旧值，A白干了。<br></td></tr><tr><td>t3</td><td>更新mysql数据库的值，over</td><td></td><td>redis是被B写回的旧值，mysql是被A更新的新值。<br>出现了，数据不一致问题。</td></tr></tbody></table><h4 id="_4、方案三、-先更新mysql数据-最后删除缓存" tabindex="-1"><a class="header-anchor" href="#_4、方案三、-先更新mysql数据-最后删除缓存" aria-hidden="true">#</a> 4、方案三、 先更新mysql数据，最后删除缓存</h4><p>假如缓存失败，或者是删除未完成，导致请求再次访问，redis命中缓存，读取的还是旧值</p><h4 id="_5、解决方案" tabindex="-1"><a class="header-anchor" href="#_5、解决方案" aria-hidden="true">#</a> 5、解决方案</h4><figure><img src="https://s2.loli.net/2023/04/22/pY6rVoqT5UZSB8G.png" alt="image-20230422140030329" tabindex="0" loading="lazy"><figcaption>image-20230422140030329</figcaption></figure><p>总结来说</p><p>第一步、更新完成数据库的时候，删除缓存数据</p><p>第二步、此时如果来了一个请求查询，此时缓存无数据，查询数据库，但是查询数据库的时候加个锁（for update）并且休眠一段时间（这个时间为缓存数据插入到数据库的两倍）</p><p>第三步、将缓存数据保存的任务放到消息队列中（celery）,设置异常重试策略，如果多次插入失败，通知运维人员</p><h4 id="_6、问题" tabindex="-1"><a class="header-anchor" href="#_6、问题" aria-hidden="true">#</a> 6、问题</h4><p><strong>为什么要加休眠时间</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>这个休眠时间为了保证将数据写入到缓存中
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>为什么要加锁</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>加锁的原因是为了在此期间数据再次发生变化
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="三、总结" tabindex="-1"><a class="header-anchor" href="#三、总结" aria-hidden="true">#</a> 三、总结</h3><p>在大多数业务场景下，我们会把Redis作为只读缓存使用。假如定位是只读缓存来说，<br> 理论上我们既可以先删除缓存值再更新数据库，也可以先更新数据库再删除缓存，但是没有完美方案，两害相衡趋其轻的原则</p><p>个人建议是，优先使用<strong>先更新数据库，再删除缓存</strong>的方案。理由如下：</p><p>1 先删除缓存值再更新数据库，有可能导致请求因缓存缺失而访问数据库，给数据库带来压力，严重导致打满mysql。</p><p>2 如果业务应用中读取数据库和写缓存的时间不好估算，那么，延迟双删中的等待时间就不好设置。</p><h3 id="四、延迟双删策略" tabindex="-1"><a class="header-anchor" href="#四、延迟双删策略" aria-hidden="true">#</a> 四、延迟双删策略</h3><p>线程A更新数据库，然后删除缓存休眠一段时间，再删除缓存</p><p>线程B查询，缓存中没有数据，然后写缓存，</p><p>这个时候数据不一致的窗口期为两次删除缓存之间的时间间隔</p><h3 id="五、两种方式的对比" tabindex="-1"><a class="header-anchor" href="#五、两种方式的对比" aria-hidden="true">#</a> 五、两种方式的对比</h3><p>方式一，更新数据库删除缓存，查询数据库的时候进行加锁，防止写入缓存的时候会降低并发性，延误并发时间为插入数据库的时间，没有缓存数据和mysql数据不一致的时候</p><p>方式二，更新数据库删除缓存，休眠后再次删除缓存，这种的话会出现不一致的时间窗口，但是时间间隔为两次删除之间的时间间隔。保证的高并发的要求</p>`,48),s=[t];function n(h,l){return e(),d("div",null,s)}const o=a(i,[["render",n],["__file","redis8、缓存双写一致性.html.vue"]]);export{o as default};
