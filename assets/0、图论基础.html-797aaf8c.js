import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as e,o,c,a as n,b as s,d as i,e as a}from"./app-2d0f66e1.js";const l={},u=a(`<h1 id="_1、图论基础" tabindex="-1"><a class="header-anchor" href="#_1、图论基础" aria-hidden="true">#</a> 1、图论基础</h1><h3 id="一、图的逻辑结构" tabindex="-1"><a class="header-anchor" href="#一、图的逻辑结构" aria-hidden="true">#</a> 一、图的逻辑结构</h3><p>图是由边和节点组成的。</p><figure><img src="https://labuladong.online/algo/images/图/0.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>本质上就是个高级点的多叉树而已，适用于树的 DFS/BFS 遍历算法，全部适用于图。</p><p>实际上我们表示一个图一般使用邻接表或者邻接矩阵来实现。</p><figure><img src="https://labuladong.online/algo/images/图/0.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://labuladong.online/algo/images/图/2.jpeg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>邻接表很直观，我把每个节点 <code>x</code> 的邻居都存到一个列表里，然后把 <code>x</code> 和这个列表关联起来，这样就可以通过一个节点 <code>x</code> 找到它的所有相邻节点。</p><p>邻接矩阵则是一个二维布尔数组，我们权且称为 <code>matrix</code>，如果节点 <code>x</code> 和 <code>y</code> 是相连的，那么就把 <code>matrix[x][y]</code> 设为 <code>true</code>（上图中绿色的方格代表 <code>true</code>）。如果想找节点 <code>x</code> 的邻居，去扫一圈 <code>matrix[x][..]</code> 就行了。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># 邻接表</span>
<span class="token comment"># graph[x] 存储 x 的所有邻居节点</span>
graph<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

<span class="token comment"># 邻接矩阵</span>
<span class="token comment"># matrix[x][y] 记录 x 是否有一条指向 y 的边</span>
matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">bool</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>邻接表：<strong>占用空间少但是无法快速判断两个节点是否相邻</strong>。但对于邻接矩阵就简单了，只要看看 <code>matrix[1][3]</code> 就知道了</p><h3 id="二、图的相关概念" tabindex="-1"><a class="header-anchor" href="#二、图的相关概念" aria-hidden="true">#</a> 二、图的相关概念</h3><p>最后，我们再明确一个图论中特有的<strong>度</strong>（degree）的概念，在无向图中，「度」就是每个节点相连的边的条数。</p><p>由于有向图的边有方向，所以有向图中每个节点「度」被细分为<strong>入度</strong>（indegree）和<strong>出度</strong>（outdegree），比如下图</p><figure><img src="https://labuladong.online/algo/images/图/0.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>其中节点 <code>3</code> 的入度为 3（有三条边指向它），出度为 1（它有 1 条边指向别的节点）。</p><h3 id="三、图的分类" tabindex="-1"><a class="header-anchor" href="#三、图的分类" aria-hidden="true">#</a> 三、图的分类</h3><p>有向图，无向图，有向加权图，无向加权图。</p><p><strong>有向加权图怎么表示</strong></p><p>使用邻接表、我们不仅仅存储某个节点 <code>x</code> 的所有邻居节点，还存储 <code>x</code> 到每个邻居的权重，就实现了加权有向图</p><p>使用邻接矩阵我们矩阵中存储权值即可。</p><p>什么是无向图，无向图就是双向图。</p><img src="https://labuladong.online/algo/images/图/3.jpeg" alt="img" style="zoom:50%;"><h3 id="四、图的遍历" tabindex="-1"><a class="header-anchor" href="#四、图的遍历" aria-hidden="true">#</a> 四、图的遍历</h3><p>数据结构被发明出来很多时候都是为了遍历和访问。所以遍历是所有数据结构的基础。</p><p>图应该如何遍历，可以参考下多叉树的遍历。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    <span class="token comment"># 前序位置</span>
    <span class="token keyword">for</span> child <span class="token keyword">in</span> root<span class="token punctuation">.</span>children<span class="token punctuation">:</span>
        traverse<span class="token punctuation">(</span>child<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是多叉树和图最大的区别就是，图中可能是包含环的，从图中的某一个节点开始遍历，有可能走了一圈又回到该节点，所以我们应该使用一个visited数组进行辅助，这个visited数组可以避免我们走回头路。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>visited <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
on_path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">traver</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> visited<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    visited<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>
    on_path<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>
    <span class="token keyword">for</span> neighbor <span class="token keyword">in</span> graph<span class="token punctuation">.</span>neighbors<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
        traverse<span class="token punctuation">(</span>graph<span class="token punctuation">,</span> neighbor<span class="token punctuation">)</span>
    on_path<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>
        
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="https://labuladong.online/algo/images/迭代遍历二叉树/1.gif" alt="img" style="zoom:50%;"><p>我们可以粗略的理解为visited 数组为灰色的节点，on_path数组相当于绿色的数组。</p><p><strong>在 <code>visited</code> 中被标记为 true 的节点用灰色表示，在 <code>onPath</code> 中被标记为 true 的节点用绿色表示</strong>，类比贪吃蛇游戏，<code>visited</code> 记录蛇经过过的格子，而 <code>onPath</code> 仅仅记录蛇身。在图的遍历过程中，<code>onPath</code> 用于判断是否成环，类比当贪吃蛇自己咬到自己（成环）的场景，这下你可以理解它们二者的区别了吧。</p><p>图的遍历和回溯算法区别为，：回溯算法关注的不是节点，而是树枝</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># DFS 算法，关注点在节点</span>
<span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;进入节点&quot;</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span>
    <span class="token keyword">for</span> child <span class="token keyword">in</span> root<span class="token punctuation">.</span>children<span class="token punctuation">:</span>
        traverse<span class="token punctuation">(</span>child<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;离开节点&quot;</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span>

<span class="token comment"># 回溯算法，关注点在树枝</span>
<span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    <span class="token keyword">for</span> child <span class="token keyword">in</span> root<span class="token punctuation">.</span>children<span class="token punctuation">:</span>
        <span class="token comment"># 做选择</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;从&quot;</span><span class="token punctuation">,</span> root<span class="token punctuation">,</span> <span class="token string">&quot;到&quot;</span><span class="token punctuation">,</span> child<span class="token punctuation">)</span>
        backtrack<span class="token punctuation">(</span>child<span class="token punctuation">)</span>
        <span class="token comment"># 撤销选择</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;从&quot;</span><span class="token punctuation">,</span> child<span class="token punctuation">,</span> <span class="token string">&quot;到&quot;</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果执行这段代码，你会发现根节点被漏掉了：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    <span class="token keyword">for</span> child <span class="token keyword">in</span> root<span class="token punctuation">.</span>children<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;进入节点 {}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span>
        traverse<span class="token punctuation">(</span>child<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;离开节点 {}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以对于这里「图」的遍历，我们应该用 DFS 算法，即把 <code>onPath</code> 的操作放到 for 循环外面，否则会漏掉记录起始点的遍历。</p>`,38),r={id:"五、题目实践——797-所有可能的路径",tabindex:"-1"},d=n("a",{class:"header-anchor",href:"#五、题目实践——797-所有可能的路径","aria-hidden":"true"},"#",-1),k={href:"https://leetcode.cn/problems/all-paths-from-source-to-target/",target:"_blank",rel:"noopener noreferrer"},v=a(`<p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出（<strong>不要求按特定顺序</strong>）</p><p><code>graph[i]</code> 是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点 <code>graph[i][j]</code>存在一条有向边）。</p><p><strong>示例 1：</strong></p><figure><img src="https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：graph = [[1,2],[3],[3],[]]
输出：[[0,1,3],[0,2,3]]
解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]
输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>n == graph.length</code></li><li><code>2 &lt;= n &lt;= 15</code></li><li><code>0 &lt;= graph[i][j] &lt; n</code></li><li><code>graph[i][j] != i</code>（即不存在自环）</li><li><code>graph[i]</code> 中的所有元素 <strong>互不相同</strong></li><li>保证输入为 <strong>有向无环图（DAG）</strong></li></ul><p>思路：</p><p>这里只需要遍历一遍图即可知道答案，那么我们遍历图需要哪些条件呢</p><ul><li>邻接表</li><li>开始节点</li></ul><p>我们只需要这两个数据就可以了，那么我们遍历图需要两个数组第一个visited,第二个onpath,这两个数据是干嘛的。</p><p>visited是为了避免走回头路，避免图中有环走入死循环，onpath是为了记录图中的数据，题目中已经说了没有环，所以我们就不再需要visited数组了。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> typing <span class="token keyword">import</span> List


<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">allPathsSourceTarget</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> graph<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>graph<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> result<span class="token punctuation">)</span>
        <span class="token keyword">return</span> result

    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> graph<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> path<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">:</span>
        path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">)</span>

        <span class="token keyword">if</span> s <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>
            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

        <span class="token keyword">for</span> v <span class="token keyword">in</span> graph<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>graph<span class="token punctuation">,</span> v<span class="token punctuation">,</span> path<span class="token punctuation">,</span> result<span class="token punctuation">)</span>
        path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这个代码还是有坑的，我们一般写递归条件需要return</p><p>但是我们发现这里没有return，为什么没有return呢？是因为我们一旦return,就会把前面path.append(s)这里的值进行重复添加。所以当我们需要return时需要这么写</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> typing <span class="token keyword">import</span> List


<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">allPathsSourceTarget</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> graph<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>graph<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> result<span class="token punctuation">)</span>
        <span class="token keyword">return</span> result

    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> graph<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> path<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">:</span>
        path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">)</span>

        <span class="token keyword">if</span> s <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>
            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span>

        <span class="token keyword">for</span> v <span class="token keyword">in</span> graph<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>graph<span class="token punctuation">,</span> v<span class="token punctuation">,</span> path<span class="token punctuation">,</span> result<span class="token punctuation">)</span>
        path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这里和我们代码随想录中写的还不一样，代码随想录中path的处理是在for循环中的，这里是在for循环外的，这里我们先要分清在for里面和外面的区别，里面是对路径进行回溯，外面是对节点进行回溯。</p><p>如果写在里面会少个根节点。那么我们可以为了维持我们之前的习惯，还是选择写在里面</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> typing <span class="token keyword">import</span> List


<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">allPathsSourceTarget</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> graph<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>graph<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> result<span class="token punctuation">)</span>
        <span class="token keyword">return</span> result

    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> graph<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> path<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> s <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>
            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span>

        <span class="token keyword">for</span> v <span class="token keyword">in</span> graph<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">:</span>
            path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>v<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>graph<span class="token punctuation">,</span> v<span class="token punctuation">,</span> path<span class="token punctuation">,</span> result<span class="token punctuation">)</span>
            path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,22);function m(g,b){const t=e("ExternalLinkIcon");return o(),c("div",null,[u,n("h3",r,[d,s(" 五、题目实践——"),n("a",k,[s("797. 所有可能的路径"),i(t)])]),v])}const f=p(l,[["render",m],["__file","0、图论基础.html.vue"]]);export{f as default};
