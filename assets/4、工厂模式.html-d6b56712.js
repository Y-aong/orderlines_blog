import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,e}from"./app-2d0f66e1.js";const t={},c=e(`<h1 id="_4、工厂模式" tabindex="-1"><a class="header-anchor" href="#_4、工厂模式" aria-hidden="true">#</a> 4、工厂模式</h1><h3 id="一、模式定义" tabindex="-1"><a class="header-anchor" href="#一、模式定义" aria-hidden="true">#</a> 一、模式定义</h3><p>工厂模式（Factory Pattern）是软件工程中一种创建型设计模式，它提供了一种创建对象的最佳方式，通过定义一个用于创建对象的接口，但让子类决定实例化哪一个类。工厂模式使得一个类的实例化延迟到其子类进行。在Python中，工厂模式可以通过多种方式实现，包括简单工厂模式、工厂方法模式和抽象工厂模式。</p><h3 id="二、实现方式" tabindex="-1"><a class="header-anchor" href="#二、实现方式" aria-hidden="true">#</a> 二、实现方式</h3><h4 id="_1、简单工厂模式" tabindex="-1"><a class="header-anchor" href="#_1、简单工厂模式" aria-hidden="true">#</a> 1、简单工厂模式</h4><p>简单工厂模式是最基础的形式，它使用单一的工厂类来封装对象创建的过程，并根据输入参数返回不同类型的对象。这种方式的优点在于易于理解和实现，但它有一个明显的缺点：当需要添加新产品时，必须修改工厂类以支持新的产品类型，这违反了面向对象设计中的开闭原则（Open/Closed Principle）。例如：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">SimpleFactory</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">publish_book</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> name <span class="token operator">==</span> <span class="token string">&#39;technical&#39;</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> TechnicalBooks<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">elif</span> name <span class="token operator">==</span> <span class="token string">&#39;literary&#39;</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> LiteraryBooks<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>SimpleFactory</code> 类负责选择并创建适当的书籍对象。然而，如果想要增加一种新的书籍类型，则需要修改 <code>publish_book</code> 方法。</p><h4 id="_2、工厂方法模式" tabindex="-1"><a class="header-anchor" href="#_2、工厂方法模式" aria-hidden="true">#</a> 2、工厂方法模式</h4><p>为了解决简单工厂模式的问题，工厂方法模式引入了一个抽象的工厂基类，并让具体的工厂子类实现具体的对象创建逻辑。这样做的好处是在不改变现有代码的情况下可以轻松地扩展新类型的产品。例如：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> abc <span class="token keyword">import</span> ABC<span class="token punctuation">,</span> abstractmethod

<span class="token keyword">class</span> <span class="token class-name">AbstractFactory</span><span class="token punctuation">(</span>ABC<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token decorator annotation punctuation">@abstractmethod</span>
    <span class="token keyword">def</span> <span class="token function">publish_book</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>

<span class="token keyword">class</span> <span class="token class-name">TechnicalFactory</span><span class="token punctuation">(</span>AbstractFactory<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">publish_book</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> TechnicalBooks<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">LiteraryFactory</span><span class="token punctuation">(</span>AbstractFactory<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">publish_book</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> LiteraryBooks<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里，<code>AbstractFactory</code> 定义了一个抽象方法 <code>publish_book()</code>，而具体的工厂如 <code>TechnicalFactory</code> 和 <code>LiteraryFactory</code> 则实现了这个方法，各自负责创建特定类型的书籍对象。</p><h4 id="_3、抽象工厂模式" tabindex="-1"><a class="header-anchor" href="#_3、抽象工厂模式" aria-hidden="true">#</a> 3、抽象工厂模式</h4><p>抽象工厂模式进一步扩展了工厂方法模式的概念，它不仅能够创建一系列相关或相互依赖的对象，而且这些对象还可以组合成不同的家族或系列。这意味着同一个工厂可以生产多个不同类型的产品，而不需要为每种产品都创建一个新的工厂类。例如，在处理不同品牌的自行车时，我们可以有一个抽象工厂来同时生产车架和轮胎。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">AbstractBikeFactory</span><span class="token punctuation">(</span>ABC<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token decorator annotation punctuation">@abstractmethod</span>
    <span class="token keyword">def</span> <span class="token function">create_frame</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>
  
    <span class="token decorator annotation punctuation">@abstractmethod</span>
    <span class="token keyword">def</span> <span class="token function">create_wheel</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>

<span class="token keyword">class</span> <span class="token class-name">FlyingPigeonFactory</span><span class="token punctuation">(</span>AbstractBikeFactory<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">create_frame</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> FlyingPigeonFrame<span class="token punctuation">(</span><span class="token punctuation">)</span>
  
    <span class="token keyword">def</span> <span class="token function">create_wheel</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> FlyingPigeonWheel<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">ForeverFactory</span><span class="token punctuation">(</span>AbstractBikeFactory<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">create_frame</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> ForeverFrame<span class="token punctuation">(</span><span class="token punctuation">)</span>
  
    <span class="token keyword">def</span> <span class="token function">create_wheel</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> ForeverWheel<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，<code>AbstractBikeFactory</code> 是一个抽象工厂，它有两个抽象方法分别用来创建车架和轮胎。具体的品牌工厂如 <code>FlyingPigeonFactory</code> 和 <code>ForeverFactory</code> 实现了这两个方法，从而可以创建相应品牌下的所有组件。</p><h3 id="三、应用场景" tabindex="-1"><a class="header-anchor" href="#三、应用场景" aria-hidden="true">#</a> 三、应用场景</h3><ul><li><strong>简单工厂模式</strong>适合于那些需求明确且不太可能频繁变化的系统。如果未来可能会有更多种类的产品加入，那么应该考虑使用更灵活的设计。</li><li><strong>工厂方法模式</strong>适用于系统中存在大量相似的对象，并且希望能够在不修改原有代码的基础上轻松添加新的对象类型。</li><li><strong>抽象工厂模式</strong>则非常适合那些需要创建一组相关联的对象的情况，尤其是在各个对象之间存在着复杂的依赖关系时。</li></ul>`,18),o=[c];function p(i,l){return s(),a("div",null,o)}const d=n(t,[["render",p],["__file","4、工厂模式.html.vue"]]);export{d as default};
