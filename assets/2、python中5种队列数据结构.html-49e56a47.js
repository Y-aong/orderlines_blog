import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,e}from"./app-2d0f66e1.js";const t={},p=e(`<h1 id="_2、python中5种队列数据结构" tabindex="-1"><a class="header-anchor" href="#_2、python中5种队列数据结构" aria-hidden="true">#</a> 2、python中5种队列数据结构</h1><h3 id="一、python基础队列-列表" tabindex="-1"><a class="header-anchor" href="#一、python基础队列-列表" aria-hidden="true">#</a> 一、python基础队列：列表</h3><h4 id="_1-1-列表作为队列的简单应用" tabindex="-1"><a class="header-anchor" href="#_1-1-列表作为队列的简单应用" aria-hidden="true">#</a> 1.1 列表作为队列的简单应用</h4><p>列表作为python中使用最常见的一种数据类型，同样也是最方便实现队列的数据结构。尽管这不是最高效的解决方案 ，但是可能是最便捷的实现方案。</p><p>列表提供了<code>append()</code>方法用于在尾部添加元素（相当于队列的入队操作），以及<code>pop(0)</code>方法来移除并返回列表的第一个元素（相当于队列的出队操作）。</p><ul><li><strong>入队（Enqueue）</strong>：使用<code>list.append()</code>方法在列表的末尾添加元素。这对应于队列中新元素的加入，遵循先进先出的原则。</li><li><strong>出队（Dequeue）</strong>：标准的列表不直接支持队列的头部移除操作 ，通常使用<code>list.pop(0)</code>来模拟。这种方法虽然实现了功能，但是效率低下，特别是当队列很大时，因为每次出队操作都需要移动后续的所有元素。</li></ul><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token comment"># 入队操作</span>
queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">&quot;任务A&quot;</span><span class="token punctuation">)</span>
queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">&quot;任务B&quot;</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;初始队列:&quot;</span><span class="token punctuation">,</span> queue<span class="token punctuation">)</span>

<span class="token comment"># 出队操作</span>
task <span class="token operator">=</span> queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;处理任务:&quot;</span><span class="token punctuation">,</span> task<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;处理后队列:&quot;</span><span class="token punctuation">,</span> queue<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>初始队列: [&#39;任务A&#39;, &#39;任务B&#39;]
处理任务: 任务A
处理后队列: [&#39;任务B&#39;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-2-缺点与优化建议" tabindex="-1"><a class="header-anchor" href="#_1-2-缺点与优化建议" aria-hidden="true">#</a> 1.2 缺点与优化建议</h4><p>虽然使用列表可以实现队列操作，但是这不是最好的方式，因为随着队列操作的进行，频繁的插入和删除可能导致内存碎片。</p><ul><li><p><strong>效率问题</strong>：由于Python列表是基于数组实现的，当执行<code>list.pop(0)</code>操作时，需要移动所有后续元素来填补空位，时间复杂度为O(n) ，在大规模数据处理时效率极低。</p></li><li><p><strong>循环利用问题</strong>：真实世界中的队列往往期望能够高效地循环利用存储空间，而列表实现的队列在不断出队后 ，无法自动复用前面的空间，导致内存使用效率不高。</p></li></ul><h3 id="二、高效队列-collections-deque" tabindex="-1"><a class="header-anchor" href="#二、高效队列-collections-deque" aria-hidden="true">#</a> 二、高效队列：<code>collections.deque</code></h3><h4 id="_2-1-deque介绍与优势" tabindex="-1"><a class="header-anchor" href="#_2-1-deque介绍与优势" aria-hidden="true">#</a> 2.1 <code>deque</code>介绍与优势</h4><p>在Python标准库中，<code>collections.deque</code>（双端队列）是一种优化的队列实现 ，特别适用于需要高效插入和删除元素的场景。相较于使用列表模拟队列，<code>deque</code>提供了更优的性能和灵活性。</p><p><code>deque</code>，全称双端队列（double-ended queue），是一种允许在其两端进行添加和删除操作的数据结构。它克服了列表作为队列使用时的主要瓶颈——出队操作的低效。deque通过使用双向链表实现 ，确保了在两端执行插入和删除操作的时间复杂度均为O(1)。</p><ul><li><strong>快速操作</strong>：无论是头部还是尾部 ，入队（append/appendleft）和出队(pop/popleft)都非常迅速。</li><li><strong>内存效率</strong>：自动管理内存，无需像列表那样移动大量元素。</li><li><strong>灵活应用</strong>：不仅限于队列 ，还可以当作栈或双端队列使用。</li></ul><h4 id="_2-2-实现快速入队与出队" tabindex="-1"><a class="header-anchor" href="#_2-2-实现快速入队与出队" aria-hidden="true">#</a> 2.2 实现快速入队与出队</h4><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque

queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 入队操作</span>
queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">&quot;任务1&quot;</span><span class="token punctuation">)</span>
queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">&quot;任务2&quot;</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;初始队列:&quot;</span><span class="token punctuation">,</span> queue<span class="token punctuation">)</span>

<span class="token comment"># 出队操作</span>
task <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;处理任务:&quot;</span><span class="token punctuation">,</span> task<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;处理后队列:&quot;</span><span class="token punctuation">,</span> queue<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>初始队列: deque([&#39;任务1&#39;, &#39;任务2&#39;])
处理任务: 任务1
处理后队列: deque([&#39;任务2&#39;])
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>限制大小</strong>：可以创建一个固定大小的deque，当达到容量上限时，新元素的加入会导致最旧的元素自动弹出 ，类似于循环队列。</li></ul><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque

<span class="token comment"># 创建一个最大长度为3的deque</span>
limited_deque <span class="token operator">=</span> deque<span class="token punctuation">(</span>maxlen<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>
limited_deque<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
limited_deque<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
limited_deque<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
limited_deque<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>  <span class="token comment"># 此时1会被自动移除</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>limited_deque<span class="token punctuation">)</span>  <span class="token comment"># 输出: deque([2, 3, 4], maxlen=3)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>双端访问</strong>：既可以从左侧添加或移除元素（<code>appendleft</code>和<code>popleft</code>） ，也可以从右侧操作 ，提供了更多操作灵活性。</li></ul><h3 id="三、并发安全-queue模块" tabindex="-1"><a class="header-anchor" href="#三、并发安全-queue模块" aria-hidden="true">#</a> 三、并发安全：queue模块</h3><h4 id="_3-1-多线程-进程安全队列" tabindex="-1"><a class="header-anchor" href="#_3-1-多线程-进程安全队列" aria-hidden="true">#</a> 3.1 多线程/进程安全队列</h4><p>在涉及多线程或多进程的并发程序设计中，数据同步和线程安全是必须面对的挑战。Python的<code>queue</code>模块为此提供了线程安全的队列类 ，包括<code>Queue</code>, <code>LifoQueue</code>（后进先出队列），以及<code>PriorityQueue</code>（优先级队列）。这些队列类内部实现了锁机制 ，确保了在多线程环境下的安全访问，避免了数据竞争和一致性问题。</p><h4 id="_3-2-queue模块核心类解析" tabindex="-1"><a class="header-anchor" href="#_3-2-queue模块核心类解析" aria-hidden="true">#</a> 3.2 queue模块核心类解析</h4><ul><li>• <strong>FIFO队列 (<code>Queue</code>)</strong>：最基本的形式 ，遵循先进先出（FIFO）原则 ，提供了<code>put()</code>方法用于插入元素到队列尾部，以及<code>get()</code>方法从队列头部移除并返回一个元素。</li><li>• <strong>LIFO队列 (<code>LifoQueue</code>)</strong>：后进先出队列，类似于堆栈，最近添加的元素将是最先被获取的元素，通过<code>put()</code>和<code>get()</code>操作实现。</li><li>• <strong>优先级队列 (<code>PriorityQueue</code>)</strong>：元素带有优先级的队列，每次出队都是优先级最高的元素。元素被赋予一个优先级数字，越小的数字代表越高的优先级。通过<code>put()</code>存放带有优先级的项，<code>get()</code>取出优先级最高的项。</li></ul><h4 id="_3-3-生产者消费者模型实例" tabindex="-1"><a class="header-anchor" href="#_3-3-生产者消费者模型实例" aria-hidden="true">#</a> 3.3 生产者消费者模型实例</h4><p>生产者消费者模型是一种经典的设计模式，常用于处理多线程或多进程间的协作。下面是一个使用<code>queue</code>模块实现的简单生产者消费者模型示例：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> threading
<span class="token keyword">import</span> time
<span class="token keyword">from</span> queue <span class="token keyword">import</span> Queue

<span class="token keyword">def</span> <span class="token function">producer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;生产者线程，向队列中添加任务&quot;&quot;&quot;</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        item <span class="token operator">=</span> <span class="token string-interpolation"><span class="token string">f&quot;产品</span><span class="token interpolation"><span class="token punctuation">{</span>i<span class="token punctuation">}</span></span><span class="token string">&quot;</span></span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;生产了 </span><span class="token interpolation"><span class="token punctuation">{</span>item<span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
        queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>item<span class="token punctuation">)</span>
        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 模拟生产间隔</span>

<span class="token keyword">def</span> <span class="token function">consumer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;消费者线程 ，从队列中获取并处理任务&quot;&quot;&quot;</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        item <span class="token operator">=</span> queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> item <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>  <span class="token comment"># 使用None作为停止信号</span>
            <span class="token keyword">break</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;消费了 </span><span class="token interpolation"><span class="token punctuation">{</span>item<span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment"># 模拟消费间隔</span>

<span class="token comment"># 创建共享的线程安全队列</span>
task_queue <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 分别启动生产者和消费者线程</span>
producer_thread <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>producer<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>task_queue<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
consumer_thread <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>consumer<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>task_queue<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

producer_thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
consumer_thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>

producer_thread<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 等待生产者线程完成</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;生产结束，发送停止信号&quot;</span><span class="token punctuation">)</span>
task_queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>  <span class="token comment"># 向队列发送结束信号</span>
consumer_thread<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 等待消费者线程完成</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此示例中，<code>producer</code>线程不断向队列中添加“产品”，而<code>consumer</code>线程则不断地从队列中取出并“消费”这些产品。通过队列作为中介 ，两者之间实现了有效的协同工作 ，同时保证了线程安全。</p><h3 id="四、高级数据结构-堆与优先队列-priorityqueue" tabindex="-1"><a class="header-anchor" href="#四、高级数据结构-堆与优先队列-priorityqueue" aria-hidden="true">#</a> 四、高级数据结构：堆与优先队列 <code>PriorityQueue</code></h3><h4 id="_4-1-何为优先队列及其应用场景" tabindex="-1"><a class="header-anchor" href="#_4-1-何为优先队列及其应用场景" aria-hidden="true">#</a> 4.1 何为优先队列及其应用场景</h4><p>优先队列是一种特殊类型的队列，其中每个元素都有一个优先级。在这样的队列中，出队操作总是移除优先级最高的元素。优先队列广泛应用于各种场景，如任务调度、事件驱动系统、Dijkstra算法中的最短路径计算、优先级中断处理等。它确保了关键或紧急的任务能够得到及时处理。</p><h4 id="_4-2-使用heapq模块实现优先队列" tabindex="-1"><a class="header-anchor" href="#_4-2-使用heapq模块实现优先队列" aria-hidden="true">#</a> 4.2 使用heapq模块实现优先队列</h4><p>Python的<code>heapq</code>模块提供了堆队列算法的实现，可以方便地用来构建优先队列。堆是一个近似完全二叉树的结构，满足父节点的值小于或等于（在最小堆中）其子节点的值。利用<code>heapq</code>，我们可以高效地实现优先队列的核心操作——插入元素（<code>heappush</code>）和获取并移除最小元素（<code>heappop</code>）。</p><p>示例代码如下：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> heapq

<span class="token keyword">class</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>_queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>_index <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 用于自定义优先级的计数器</span>

    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> item<span class="token punctuation">,</span> priority<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">&quot;&quot;&quot;将元素插入队列，可选优先级&quot;&quot;&quot;</span>
        heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_queue<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">-</span>priority<span class="token punctuation">,</span> self<span class="token punctuation">.</span>_index<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 使用负优先级进行最小堆排序</span>
        self<span class="token punctuation">.</span>_index <span class="token operator">+=</span> <span class="token number">1</span>

    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">&quot;&quot;&quot;移除并返回优先级最高的元素&quot;&quot;&quot;</span>
        <span class="token keyword">return</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_queue<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment"># 返回元素部分</span>

pq <span class="token operator">=</span> PriorityQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>
pq<span class="token punctuation">.</span>push<span class="token punctuation">(</span><span class="token string">&quot;任务A&quot;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
pq<span class="token punctuation">.</span>push<span class="token punctuation">(</span><span class="token string">&quot;任务B&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
pq<span class="token punctuation">.</span>push<span class="token punctuation">(</span><span class="token string">&quot;任务C&quot;</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>pq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 应输出优先级最高的任务C</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>pq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 接下来是任务A</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-3-自定义比较函数优化优先级处理" tabindex="-1"><a class="header-anchor" href="#_4-3-自定义比较函数优化优先级处理" aria-hidden="true">#</a> 4.3 自定义比较函数优化优先级处理</h4><p>在某些情况下 ，优先级可能基于复杂的逻辑，而不仅仅是简单的数值比较。虽然可以通过转换策略间接实现 ，但直接提供自定义比较函数给<code>heapq</code>模块更为灵活。不过，<code>heapq</code>本身不直接支持传入自定义比较函数 ，而是依赖于元素的自然顺序或显式指定的负优先级值。因此，为了实现这一需求 ，通常是在元素中包含或绑定比较逻辑。</p><p>例如，如果任务类本身定义了比较操作，那么直接使用该类的实例即可：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>class Task:
    def __init__(self, name, priority):
        self.name = name
        self.priority = priority

    def __lt__(self, other):
        return self.priority &lt; other.priority  # 定义优先级比较

# 使用Task实例作为优先队列的元素
pq = []
heapq.heapify(pq)  # 将列表转换为堆结构
heapq.heappush(pq, Task(&quot;任务D&quot;, 5))
heapq.heappush(pq, Task(&quot;任务E&quot;, 9))

print(heapq.heappop(pq).name)  # 应输出优先级最低的任务D
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这种方式，我们可以更灵活地控制优先级的比较逻辑，使优先队列更加适应复杂的应用场景。</p><h4 id="_4-4-实时调度与top-k问题解决" tabindex="-1"><a class="header-anchor" href="#_4-4-实时调度与top-k问题解决" aria-hidden="true">#</a> 4.4 实时调度与Top-K问题解决</h4><ul><li>• <strong>实时调度</strong>：在操作系统和网络通信等领域 ，堆可实现高效的任务调度算法，如事件驱动编程中的事件调度，能确保优先级高的任务优先得到处理。</li><li>• <strong>Top-K问题</strong>：当需要找出一组数据中的前K个最大或最小元素时，堆是一个理想的数据结构。通过维护一个大小为K的最小堆（找最大K个元素）或最大堆（找最小K个元素） ，可以在O(NlogK)的时间复杂度内完成。</li></ul><p>示例：使用<code>heapq</code>求解Top-3最大数。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> heapq

numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
top_k <span class="token operator">=</span> <span class="token number">3</span>

<span class="token comment"># 使用nlargest函数直接求解Top-K问题</span>
top_three <span class="token operator">=</span> heapq<span class="token punctuation">.</span>nlargest<span class="token punctuation">(</span>top_k<span class="token punctuation">,</span> numbers<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;Top-</span><span class="token interpolation"><span class="token punctuation">{</span>top_k<span class="token punctuation">}</span></span><span class="token string">最大数：</span><span class="token interpolation"><span class="token punctuation">{</span>top_three<span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>

<span class="token comment"># 输出结果：</span>
<span class="token comment"># Top-3最大数：[20, 15, 12]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过<code>heapq</code>模块，开发者可以轻松实现复杂的堆相关应用 ，满足对高效数据排序、实时处理以及特定问题求解的需求。</p><h3 id="五、扩展视野-协程和asyncio-queue" tabindex="-1"><a class="header-anchor" href="#五、扩展视野-协程和asyncio-queue" aria-hidden="true">#</a> 五、扩展视野：协程和asyncio.Queue</h3><h4 id="_5-1-协程基础与async-await" tabindex="-1"><a class="header-anchor" href="#_5-1-协程基础与async-await" aria-hidden="true">#</a> 5.1 协程基础与async/await</h4><p>协程（Coroutine）是Python中用于异步编程的一种高级控制流特性。它们允许非阻塞地执行多个任务，提高了I/O密集型程序的效率。从Python 3.5起，引入了<code>async/await</code>语法 ，大大简化了异步编程模型。</p><p><code>async</code>关键字用于声明一个协程函数（coroutine function），而<code>await</code>用于等待一个异步操作的结果，直到该操作完成。这意味着在等待期间 ，控制权可以交给其他协程继续执行，从而实现了并发执行的效果。</p><h4 id="_5-2-异步编程中的队列应用" tabindex="-1"><a class="header-anchor" href="#_5-2-异步编程中的队列应用" aria-hidden="true">#</a> 5.2 异步编程中的队列应用</h4><p>在异步编程领域，<code>asyncio.Queue</code>是<code>asyncio</code>模块提供的一个线程安全的队列 ，特别适合在协程之间传递数据。它支持异步地将数据放入队列（<code>put()</code>）和从中取出数据（<code>get()</code>） ，非常适合实现生产者-消费者模型，尤其在处理I/O密集型任务时，能显著提高程序性能。</p><p>示例：使用<code>asyncio.Queue</code>处理并发请求。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> asyncio
<span class="token keyword">import</span> aiohttp

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">fetch</span><span class="token punctuation">(</span>session<span class="token punctuation">,</span> url<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">async</span> <span class="token keyword">with</span> session<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token keyword">as</span> response<span class="token punctuation">:</span>
        data <span class="token operator">=</span> <span class="token keyword">await</span> response<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">await</span> queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>data<span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">process_queue</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        data <span class="token operator">=</span> <span class="token keyword">await</span> queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> data <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">break</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;处理响应数据：</span><span class="token interpolation"><span class="token punctuation">{</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token format-spec">50]</span><span class="token punctuation">}</span></span><span class="token string">...&quot;</span></span><span class="token punctuation">)</span>
        queue<span class="token punctuation">.</span>task_done<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>urls<span class="token punctuation">)</span><span class="token punctuation">:</span>
    queue <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">async</span> <span class="token keyword">with</span> aiohttp<span class="token punctuation">.</span>ClientSession<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> session<span class="token punctuation">:</span>
        tasks <span class="token operator">=</span> <span class="token punctuation">[</span>fetch<span class="token punctuation">(</span>session<span class="token punctuation">,</span> url<span class="token punctuation">,</span> queue<span class="token punctuation">)</span> <span class="token keyword">for</span> url <span class="token keyword">in</span> urls<span class="token punctuation">]</span>
        asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>process_queue<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token operator">*</span>tasks<span class="token punctuation">)</span>
    <span class="token keyword">await</span> queue<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 等待所有任务完成</span>

urls <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;https://www.baidu.com&quot;</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">10</span>  <span class="token comment"># 示例URL列表</span>
asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span>urls<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此代码示例展示了如何使用<code>asyncio.Queue</code>来收集并发HTTP请求的响应数据 ，并通过另一个协程异步处理这些数据。</p><h4 id="_5-3-提升i-o密集型任务性能" tabindex="-1"><a class="header-anchor" href="#_5-3-提升i-o密集型任务性能" aria-hidden="true">#</a> 5.3 提升I/O密集型任务性能</h4><p>下面是一个使用<code>asyncio.Queue</code>和协程提升I/O密集型任务性能的示例。假设我们有多个URL需要并发下载，每个下载任务视为一个异步操作，我们可以利用<code>asyncio</code>和<code>asyncio.Queue</code>来高效地管理这些任务。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> asyncio
<span class="token keyword">import</span> aiohttp

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">download</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">async</span> <span class="token keyword">with</span> aiohttp<span class="token punctuation">.</span>ClientSession<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> session<span class="token punctuation">:</span>
        <span class="token keyword">async</span> <span class="token keyword">with</span> <span class="token keyword">await</span> session<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token keyword">as</span> response<span class="token punctuation">:</span>
            content <span class="token operator">=</span> <span class="token keyword">await</span> response<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;Downloaded </span><span class="token interpolation"><span class="token punctuation">{</span>url<span class="token punctuation">}</span></span><span class="token string"> - </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token builtin">len</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string"> bytes&quot;</span></span><span class="token punctuation">)</span>
            <span class="token keyword">await</span> queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>url<span class="token punctuation">)</span>  <span class="token comment"># 完成后通知队列</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>urls<span class="token punctuation">)</span><span class="token punctuation">:</span>
    queue <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>
    tasks <span class="token operator">=</span> <span class="token punctuation">[</span>download<span class="token punctuation">(</span>url<span class="token punctuation">,</span> queue<span class="token punctuation">)</span> <span class="token keyword">for</span> url <span class="token keyword">in</span> urls<span class="token punctuation">]</span>

    <span class="token comment"># 启动所有任务</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token operator">*</span>tasks<span class="token punctuation">)</span>

    <span class="token comment"># 等待所有任务完成</span>
    <span class="token keyword">while</span> <span class="token keyword">not</span> queue<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">await</span> queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 阻塞直到所有任务完成通知</span>

urls <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;https://example.com&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;https://example.org&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;https://example.net&quot;</span>
<span class="token punctuation">]</span>

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span>urls<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，每个URL的下载任务由单独的协程处理，它们并发执行 ，充分利用了异步I/O ，提升了整体的下载效率。<code>asyncio.Queue</code>在这里起到了协调作用，确保所有下载任务完成后才结束程序 ，展示了在异步编程中队列的高效应用。</p>`,63),o=[p];function c(i,u){return s(),a("div",null,o)}const r=n(t,[["render",c],["__file","2、python中5种队列数据结构.html.vue"]]);export{r as default};
