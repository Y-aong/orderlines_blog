import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as n,e as l}from"./app-2d0f66e1.js";const s={},r=l(`<h1 id="_23、join-优化" tabindex="-1"><a class="header-anchor" href="#_23、join-优化" aria-hidden="true">#</a> 23、JOIN 优化</h1><h3 id="一、定义" tabindex="-1"><a class="header-anchor" href="#一、定义" aria-hidden="true">#</a> 一、定义</h3><p>JOIN 是 MySQL 用来进行联表操作的，用来匹配两个表的数据，筛选并合并出符合我们要求的结果集。</p><p>JOIN 操作有多种方式，取决于最终数据的合并效果。常用连接方式的有以下几种:</p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672133064003/55df110a70d9450283a9a2bf0269e2b1.png" alt="image.png" style="zoom:80%;"><h3 id="二、什么是驱动表" tabindex="-1"><a class="header-anchor" href="#二、什么是驱动表" aria-hidden="true">#</a> 二、什么是驱动表 ?</h3><ul><li>多表关联查询时,第一个被处理的表就是驱动表,使用驱动表去关联其他表.</li><li>驱动表的确定非常的关键,会直接影响多表关联的顺序,也决定后续关联查询的性能</li></ul><p>驱动表的选择要遵循一个规则:</p><ul><li>在对最终的结果集没有影响的前提下,优先选择结果集最小的那张表作为驱动表</li></ul><h3 id="三种-join-算法" tabindex="-1"><a class="header-anchor" href="#三种-join-算法" aria-hidden="true">#</a> 三种 JOIN 算法</h3><p>1.Simple Nested-Loop Join（ 简单的嵌套循环连接 )</p><ul><li><p><strong>简单来说嵌套循环连接算法就是一个双层 for 循环 ，通过循环外层表的行数据，逐个与内层表的所有行数据进行比较来获取结果.</strong></p></li><li><p><strong>这种算法是最简单的方案，性能也一般。对内循环没优化。</strong></p></li><li><p><strong>例如有这样一条 SQL:</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>-- 连接用户表与订单表 连接条件是 u.id = o.user_id
select * from user t1 left join order t2 on t1.id = t2.user_id;
-- user表为驱动表,order表为被驱动表
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>转换成代码执行时的思路是这样的:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>for(user表行 uRow : user表){
    for(Order表的行 oRow : order表){
        if(uRow.id = oRow.user_id){
            return uRow;
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>匹配过程如下图</strong><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672133064003/b471d0b4f2da457892be9bce33827285.png" alt="image.png" loading="lazy"></p></li><li><p><strong>SNL 的特点</strong></p><ul><li><strong>简单粗暴容易理解，就是通过双层循环比较数据来获得结果</strong></li><li><strong>查询效率会非常慢,假设 A 表有 N 行，B 表有 M 行。SNL 的开销如下：</strong><ul><li><strong>A 表扫描 1 次。</strong></li><li><strong>B 表扫描 M 次。</strong></li><li><strong>一共有 N 个内循环，每个内循环要 M 次，一共有内循环 N * M 次</strong></li></ul></li></ul></li></ul><p><strong>2) Index Nested-Loop Join（ 索引嵌套循环连接 ）</strong></p><ul><li>Index Nested-Loop Join 其优化的思路: <strong>主要是为了减少内层表数据的匹配次数</strong> , 最大的区别在于，用来进行 join 的字段已经在被驱动表中建立了索引。</li><li>从原来的 <code>匹配次数 = 外层表行数 * 内层表行数</code> , 变成了 <code>匹配次数 = 外层表的行数 * 内层表索引的高度</code> ，极大的提升了 join 的性能。</li><li>当 <code>order</code> 表的 <code>user_id</code> 为索引的时候执行过程会如下图：</li></ul><figure><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672133064003/524e38edbd0d46b5a3642a0cc2af786c.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p><strong>注意：使用 Index Nested-Loop Join 算法的前提是匹配的字段必须建立了索引。</strong></p><p><strong>3) Block Nested-Loop Join( 块嵌套循环连接 )</strong></p><p>如果 join 的字段有索引，MySQL 会使用 INL 算法。如果没有的话，MySQL 会如何处理？</p><p>因为不存在索引了，所以被驱动表需要进行扫描。这里 MySQL 并不会简单粗暴的应用 SNL 算法，而是加入了 buffer 缓冲区，降低了内循环的个数，也就是被驱动表的扫描次数。<br><img src="" alt="" loading="lazy"><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672133064003/df7920c57eb449a68ae9fb902a976729.png" alt="image.png" loading="lazy"></p><ul><li><p>在外层循环扫描 user 表中的所有记录。扫描的时候，会把需要进行 join 用到的列都缓存到 buffer 中。buffer 中的数据有一个特点，里面的记录不需要一条一条地取出来和 order 表进行比较，而是整个 buffer 和 order 表进行批量比较。</p></li><li><p>如果我们把 buffer 的空间开得很大，可以容纳下 user 表的所有记录，那么 order 表也只需要访问一次。</p></li><li><p>MySQL 默认 buffer 大小 256K，如果有 n 个 join 操作，会生成 n-1 个 join buffer。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; show variables like &#39;%join_buffer%&#39;;
+------------------+--------+
| Variable_name    | Value  |
+------------------+--------+
| join_buffer_size | 262144 |
+------------------+--------+

mysql&gt; set session join_buffer_size=262144;
Query OK, 0 rows affected (0.00 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="四、join-优化总结" tabindex="-1"><a class="header-anchor" href="#四、join-优化总结" aria-hidden="true">#</a> 四、JOIN 优化总结</h3><ol><li>永远用小结果集驱动大结果集(其本质就是减少外层循环的数据数量)</li><li>为匹配的条件增加索引(减少内层表的循环匹配次数)</li><li>增大 join buffer size 的大小（一次缓存的数据越多，那么内层包的扫表次数就越少）</li><li>减少不必要的字段查询（字段越少，join buffer 所缓存的数据就越多</li></ol>`,22),o=[r];function a(d,t){return i(),n("div",null,o)}const f=e(s,[["render",a],["__file","mysql优化3、join优化.html.vue"]]);export{f as default};
