import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as e,e as s}from"./app-2d0f66e1.js";const d={},n=s(`<h1 id="_4、sql的执行过程" tabindex="-1"><a class="header-anchor" href="#_4、sql的执行过程" aria-hidden="true">#</a> 4、sql的执行过程</h1><h3 id="一、一条sql语句的执行过程详解" tabindex="-1"><a class="header-anchor" href="#一、一条sql语句的执行过程详解" aria-hidden="true">#</a> 一、一条sql语句的执行过程详解</h3><figure><img src="https://pdai.tech/images/db/mysql/db-mysql-sql-8.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="整体流程" tabindex="-1"><a class="header-anchor" href="#整体流程" aria-hidden="true">#</a> 整体流程</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>1、用户通过通信协议发送请求到数据库连接池
2、5.6版本查询缓存/8.0,交给sql接口
3、sql解析为mysql可以识别的语言
4、交给sql查询优化器，经过优化器的计算，根据io成本和cpu成本计算出一条条的执行计划
5、将执行计划交给存储引擎进行执行
6、将结果返回给客户端
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="mysql驱动" tabindex="-1"><a class="header-anchor" href="#mysql驱动" aria-hidden="true">#</a> mysql驱动</h4><figure><img src="https://pdai.tech/images/db/mysql/db-mysql-sql-1.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="数据库连接池" tabindex="-1"><a class="header-anchor" href="#数据库连接池" aria-hidden="true">#</a> 数据库连接池</h4><p>系统在访问 MySQL 数据库的时候，建立的连接并不是每次请求都会去创建的，而是从数据库连接池中去获取，这样就解决了因为反复的创建和销毁连接而带来的性能损耗问题了。不过这里有个小问题，业务系统是并发的，而 MySQL 接受请求的线程呢，只有一个？</p><p>其实 MySQL 的架构体系中也已经提供了这样的一个池子，也是数据库连池。双方都是通过数据库连接池来管理各个连接的，这样一方面线程之前不需要是争抢连接，更重要的是不需要反复的创建的销毁连接。</p><hr><p>系统在访问 MySQL 数据库的时候，建立的连接并不是每次请求都会去创建的，而是从数据库连接池中去获取，这样就解决了因为反复的创建和销毁连接而带来的性能损耗问题了。不过这里有个小问题，业务系统是并发的，而 MySQL 接受请求的线程呢，只有一个？</p><p>其实 MySQL 的架构体系中也已经提供了这样的一个池子，也是数据库连池。双方都是通过数据库连接池来管理各个连接的，这样一方面线程之前不需要是争抢连接，更重要的是不需要反复的创建的销毁连接。</p><figure><img src="https://pdai.tech/images/db/mysql/db-mysql-sql-4.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="sql-接口" tabindex="-1"><a class="header-anchor" href="#sql-接口" aria-hidden="true">#</a> SQL 接口</h4><p>MySQL 中处理请求的线程在获取到请求以后获取 SQL 语句去交给 SQL 接口去处理。</p><h4 id="查询解析器" tabindex="-1"><a class="header-anchor" href="#查询解析器" aria-hidden="true">#</a> 查询解析器</h4><p>但是这个 SQL 是写给我们人看的，机器哪里知道你在说什么？这个时候解析器就上场了。他会将 SQL 接口传递过来的 SQL 语句进行解析，翻译成 MySQL 自己能认识的语言，具体可以看<a href="">MySQL - MySQL中SQL是如何解析的</a>。</p><h4 id="mysql-查询优化器" tabindex="-1"><a class="header-anchor" href="#mysql-查询优化器" aria-hidden="true">#</a> MySQL 查询优化器</h4><p>查询优化器内部具体怎么实现的我们不需要是关心，我需要知道的是 MySQL 会帮我去使用他自己认为的最好的方式去优化这条 SQL 语句，并生成一条条的执行计划，比如你创建了多个索引，MySQL 会依据成本最小原则来选择使用对应的索引，这里的成本主要包括两个方面, IO 成本和 CPU 成本</p><p><strong>IO 成本</strong>: 即从磁盘把数据加载到内存的成本，默认情况下，读取数据页的 IO 成本是 1，MySQL 是以页的形式读取数据的，即当用到某个数据时，并不会只读取这个数据，而会把这个数据相邻的数据也一起读到内存中，这就是有名的程序局部性原理，所以 MySQL 每次会读取一整页，一页的成本就是 1。所以 IO 的成本主要和页的大小有关</p><p><strong>CPU 成本</strong>：将数据读入内存后，还要检测数据是否满足条件和排序等 CPU 操作的成本，显然它与行数有关，默认情况下，检测记录的成本是 0.2。</p><p>MySQL 优化器 会计算 「IO 成本 + CPU」 成本最小的那个索引来执行</p><figure><img src="https://pdai.tech/images/db/mysql/db-mysql-sql-7.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>优化器执行选出最优索引等步骤后，会去调用存储引擎接口，开始去执行被 MySQL 解析过和优化过的 SQL 语句</p><h4 id="存储引擎" tabindex="-1"><a class="header-anchor" href="#存储引擎" aria-hidden="true">#</a> 存储引擎</h4><p>查询优化器会调用存储引擎的接口，去执行 SQL，也就是说真正执行 SQL 的动作是在存储引擎中完成的。数据是被存放在内存或者是磁盘中的</p><h4 id="执行器" tabindex="-1"><a class="header-anchor" href="#执行器" aria-hidden="true">#</a> 执行器</h4><p>执行器是一个非常重要的组件，因为前面那些组件的操作最终必须通过执行器去调用存储引擎接口才能被执行。执行器最终最根据一系列的执行计划去调用存储引擎的接口去完成 SQL 的执行</p><figure><img src="https://pdai.tech/images/db/mysql/db-mysql-sql-8.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>`,30),r=[n];function t(l,h){return i(),e("div",null,r)}const g=a(d,[["render",t],["__file","basic4、一条sql的执行过程.html.vue"]]);export{g as default};
