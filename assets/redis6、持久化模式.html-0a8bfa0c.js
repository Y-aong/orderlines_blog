import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as a,e as s}from"./app-2d0f66e1.js";const n={},r=s(`<h1 id="_6、持久化机制" tabindex="-1"><a class="header-anchor" href="#_6、持久化机制" aria-hidden="true">#</a> 6、持久化机制</h1><p>Redis 的数据全部在内存里，如果突然宕机，数据就会全部丢失，因此必须有一种机制来保证 Redis 的数据不会因为故障而丢失，这种机制就是 Redis 的持久化机制。</p><p>Redis 的持久化机制有两种，第一种是RDB快照，第二种是 AOF 日志。快照是一次全量备份，AOF 日志是连续的增量备份。快照是内存数据的二进制序列化形式，在存储上非常紧凑，而 AOF 日志记录的是内存数据修改的指令记录文本。</p><h3 id="一、rdb机制" tabindex="-1"><a class="header-anchor" href="#一、rdb机制" aria-hidden="true">#</a> 一、RDB机制</h3><p>RDB快照是某个时间点的一次全量数据备份，是二进制文件，在存储上非常紧凑。</p><p>RDB持久化触发机制分为：<strong>手动触发</strong>和<strong>自动触发</strong> <strong>手动触发</strong></p><p><code>save命令</code>：会阻塞当前服务器，直到RDB完成为止，如果数据量大的话会造成长时间的阻塞，线上环境一般禁止使用 <code>save命令</code>：就是background save，执行bgsave命令时Redis主进程会fork一个子进程来完成RDB的过程，完成后自动结束（操作系统的多进程Copy On Write机制，简称COW）。所以Redis主进程阻塞时间只有fork阶段的那一下。相对于save，阻塞时间很短。</p><p><strong>自动触发</strong></p><p>场景一：配置redis.conf，触发规则，自动执行</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># 当在规定的时间内，Redis发生了写操作的个数满足条件，会触发发生BGSAVE命令。
# save &lt;seconds&gt; &lt;changes&gt;
# 当用户设置了多个save的选项配置，只要其中任一条满足，Redis都会触发一次BGSAVE操作
save 900 1 
save 300 10 
save 60 10000
# 以上配置的含义：900秒之内至少一次写操作、300秒之内至少发生10次写操作、
# 60秒之内发生至少10000次写操作，只要满足任一条件，均会触发bgsave
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>场景二：执行shutdown命令关闭服务器时，如果没有开启AOF持久化功能，那么会自动执行一次bgsave</p><p>场景三：主从同步（slave和master建立同步机制）</p><figure><img src="https://pic3.zhimg.com/v2-2fec2f1675ac45234f63d94bdab2bfd6_b.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="二、rdb执行流程" tabindex="-1"><a class="header-anchor" href="#二、rdb执行流程" aria-hidden="true">#</a> 二、RDB执行流程</h3><p>Redis 使用操作系统的多进程 cow(Copy On Write) 机制来实现RDB快照持久化</p><ol><li><p>执行bgsave命令的时候，Redis主进程会检查是否有子进程在执行RDB/AOF持久化任务，如果有的话，直接返回</p></li><li><p>Redis主进程会fork一个子进程来执行执行RDB操作，fork操作会对主进程造成阻塞（影响Redis的读写），fork操作完成后会发消息给主进程，从而不再阻塞主进程。（阻塞仅指主进程fork子进程的过程，后续子进程执行操作时不会阻塞）</p></li><li><p>RDB子进程会根据Redis主进程的内存生成临时的快照文件，持久化完成后会使用临时快照文件替换掉原来的RDB文件。（该过程中主进程的读写不受影响，但Redis的写操作不会同步到主进程的主内存中，而是会写到一个临时的内存区域作为一个副本）</p></li><li><p>子进程完成RDB持久化后会发消息给主进程，通知RDB持久化完成（将上阶段内存副本中的增量写数据同步到主内存）</p></li></ol><h3 id="三、rdb的优缺点" tabindex="-1"><a class="header-anchor" href="#三、rdb的优缺点" aria-hidden="true">#</a> 三、RDB的优缺点</h3><p><strong>优点</strong></p><ul><li>RDB文件小，非常适合定时备份，用于灾难恢复</li><li>Redis加载RDB文件的速度比AOF快很多，因为RDB文件中直接存储的时内存数据，而AOF文件中存储的是一条条命令，需要重演命令。</li></ul><p><strong>缺点</strong></p><ul><li>RDB无法做到实时持久化，若在两次bgsave间宕机，则会丢失区间（分钟级）的增量数据，不适用于实时性要求较高的场景</li><li>RDB的cow机制中，fork子进程属于重量级操作，并且会阻塞redis主进程</li><li>存在老版本的Redis不兼容新版本RDB格式文件的问题</li><li></li></ul><h3 id="四、aof-append-only-file-日志" tabindex="-1"><a class="header-anchor" href="#四、aof-append-only-file-日志" aria-hidden="true">#</a> 四、AOF（append only file）日志</h3><p>AOF日志是持续增量的备份，是基于写命令存储的可读的文本文件。AOF日志会在持续运行中持续增大，由于Redis重启过程需要优先加载AOF日志进行指令重放以恢复数据，恢复时间会无比漫长。所以需要定期进行AOF重写，对AOF日志进行瘦身。目前AOF是Redis持久化的主流方式。</p><h4 id="_2-1-开启方式" tabindex="-1"><a class="header-anchor" href="#_2-1-开启方式" aria-hidden="true">#</a> 2.1 开启方式</h4><p>AOF默认是关闭的，通过redis.conf配置文件进行开启</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>## 此选项为aof功能的开关，默认为“no”，可以通过“yes”来开启aof功能  
## 只有在“yes”下，aof重写/文件同步等特性才会生效  
appendonly yes  

## 指定aof文件名称  
appendfilename appendonly.aof  

## 指定aof操作中文件同步策略，有三个合法值：always everysec no,默认为everysec  
appendfsync everysec  
## 在aof-rewrite期间，appendfsync是否暂缓文件同步，&quot;no&quot;表示“不暂缓”，“yes”表示“暂缓”，默认为“no”  
no-appendfsync-on-rewrite no  

## aof文件rewrite触发的最小文件尺寸(mb,gb),只有大于此aof文件大于此尺寸是才会触发rewrite，默认“64mb”，建议“512mb”  
auto-aof-rewrite-min-size 64mb  

## 相对于“上一次”rewrite，本次rewrite触发时aof文件应该增长的百分比  
## 每一次rewrite之后，redis都会记录下此时“新aof”文件的大小(例如A)
## aof文件增长到A*(1 + p)之后，触发下一次rewrite，每一次aof记录的添加，都会检测当前aof文件的尺寸。  
auto-aof-rewrite-percentage 100
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>AOF是文件操作，对于变更操作比较密集的server，那么将造成磁盘IO的负荷加重。此外linux对文件操作采取了“延迟写入”手段，即并非每次write操作都会触发实际磁盘操作，而是进入了buffer中，当buffer数据达到阀值时触发实际写入(也有其他时机)，这是linux对文件系统的优化。</p><p>Linux 的<code>glibc</code>提供了<code>fsync(int fd)</code>函数可以将指定文件的内容强制从内核缓存刷到磁盘。只要 Redis 进程实时调用 fsync 函数就可以保证 aof 日志不丢失。但是 fsync 是一个磁盘 IO 操作，它很慢！如果 Redis 执行一条指令就要 fsync 一次，那么 Redis 高性能的地位就不保了。</p><p>因此在上述配置文件中，可观察到Redis中提供了3中AOF记录同步选项：</p><ul><li><p>always：每一条AOF记录都立即同步到文件，性能很低，但较为安全。</p></li><li><p>everysec：每秒同步一次，性能和安全都比较中庸的方式，也是redis推荐的方式。如果遇到物理服务器故障，可能导致最多1秒的AOF记录丢失。</p></li><li><p>no：Redis永不直接调用文件同步，而是让操作系统来决定何时同步磁盘。性能较好，但很不安全。</p></li></ul><h4 id="_2-2-重写-rewrite-机制" tabindex="-1"><a class="header-anchor" href="#_2-2-重写-rewrite-机制" aria-hidden="true">#</a> 2.2 重写（rewrite）机制</h4><p>AOF日志会在持续运行中持续增大，需要定期进行AOF重写，对AOF日志进行瘦身。</p><p><strong>AOF Rewrite</strong> 虽然是“压缩”AOF文件的过程，但并非采用“基于原AOF文件”来重写或压缩，而是采取了类似RDB快照的方式：基于Copy On Write，全量遍历内存中数据，然后逐个序列到AOF文件中。因此AOF rewrite能够正确反应当前内存数据的状态。</p><p>AOF重写（bgrewriteaof）和RDB快照写入（bgsave）过程类似，二者都消耗磁盘IO。Redis采取了“schedule”策略：无论是“人工干预”还是系统触发，快照和重写需要逐个被执行。</p><p>重写过程中，对于新的变更操作将仍然被写入到原AOF文件中，同时这些新的变更操作也会被Redis收集起来。当内存中的数据被全部写入到新的AOF文件之后，收集的新的变更操作也将被一并追加到新的AOF文件中。然后将新AOF文件重命名为appendonly.aof，使用新AOF文件替换老文件，此后所有的操作都将被写入新的AOF文件。</p><h4 id="_2-3-触发机制" tabindex="-1"><a class="header-anchor" href="#_2-3-触发机制" aria-hidden="true">#</a> 2.3 触发机制</h4><p>和RDB类似，AOF触发机制也分为：<strong>手动触发</strong>和<strong>自动触发</strong></p><p><strong>手动触发</strong> 直接调用bgrewriteaof命令</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>redis-cli -h ip -p port bgrewriteaof
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>自动触发</strong></p><p>根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>auto-aof-rewrite-min-size:表示运行AOF重写时文件最小体积，默认为64MB（我们线上是512MB）。

auto-aof-rewrite-percentage:代表当前AOF文件空间（aof_current_size）和上一次重写后AOF文件空间（aof_base_size）的值
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>自动触发时机：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>(aof_current_size &gt; auto-aof-rewrite-min-size ) &amp;&amp; (aof_current_size - aof_base_size) / aof_base_size &gt;= auto-aof-rewrite-percentage
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中aof_current_size和aof_base_size可以在info Persistence统计信息中查看。</p><h4 id="_2-4-aof的优缺点" tabindex="-1"><a class="header-anchor" href="#_2-4-aof的优缺点" aria-hidden="true">#</a> 2.4 AOF的优缺点</h4><p><strong>优点</strong> AOF只是追加写日志文件，对服务器性能影响较小，速度比RDB要快，消耗的内存较少</p><p><strong>缺点</strong></p><ul><li>AOF方式生成的日志文件太大，需要不断AOF重写，进行瘦身。</li><li>即使经过AOF重写瘦身，由于文件是文本文件，文件体积较大（相比于RDB的二进制文件）。</li><li>AOF重演命令式的恢复数据，速度显然比RDB要慢。</li><li></li></ul><h3 id="三、redis-4-0-混合持久化" tabindex="-1"><a class="header-anchor" href="#三、redis-4-0-混合持久化" aria-hidden="true">#</a> 三、Redis 4.0 混合持久化</h3><ul><li>仅使用RDB快照方式恢复数据，由于快照时间粒度较大，时回丢失大量数据。</li><li>仅使用AOF重放方式恢复数据，日志性能相对 rdb 来说要慢。在 Redis 实例很大的情况下，启动需要花费很长的时间。</li></ul><p>Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——<strong>混合持久化</strong>。将 rdb 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。相当于：</p><ul><li>大量数据使用粗粒度（时间上）的rdb快照方式，性能高，恢复时间快。</li><li>增量数据使用细粒度（时间上）的AOF日志方式，尽量保证数据的不丢失。</li></ul><p>在 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。</p><p><strong>问题：混合持久化是最佳方式吗？</strong></p><p>不一定。</p><p>首先，混合持久化是Redis 4.0才引入的特性，现在很多 公司可能都还在使用3.x版本。使用不了这一特性。</p><p>另外，可以使用下面这种方式。Master使用AOF，Slave使用RDB快照，master需要首先确保数据完整性，它作为数据备份的第一选择；slave提供只读服务或仅作为备机，它的主要目的就是快速响应客户端read请求或灾切换。</p>`,58),d=[r];function l(t,o){return i(),a("div",null,d)}const v=e(n,[["render",l],["__file","redis6、持久化模式.html.vue"]]);export{v as default};
