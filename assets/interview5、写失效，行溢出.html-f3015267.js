import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as a,e as s}from"./app-2d0f66e1.js";const o={},t=s(`<h1 id="_16、写失效-行溢出" tabindex="-1"><a class="header-anchor" href="#_16、写失效-行溢出" aria-hidden="true">#</a> 16、写失效，行溢出</h1><h3 id="一、什么是写失效" tabindex="-1"><a class="header-anchor" href="#一、什么是写失效" aria-hidden="true">#</a> 一、什么是写失效</h3><h4 id="_1、原因" tabindex="-1"><a class="header-anchor" href="#_1、原因" aria-hidden="true">#</a> 1、原因</h4><p>InnoDB 的页和操作系统的页大小不一致，InnoDB 页大小一般为 16K，操作系统页大小为 4K，InnoDB 的页写入到磁盘时，一个页需要分 4 次写。</p><p>如果存储引擎正在写入页的数据到磁盘时发生了宕机，可能出现页只写了一部分的情况，比如只写了 4K，就宕机了，这种情况叫做部分写失效（partial page write），可能会导致数据丢失。</p><figure><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672133064003/186aaf40085542d5a790025d9577b34d.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="双写缓冲区-doublewrite-buffer" tabindex="-1"><a class="header-anchor" href="#双写缓冲区-doublewrite-buffer" aria-hidden="true">#</a> 双写缓冲区<code> Doublewrite Buffer</code></h3><p>为了解决写失效问题，InnoDB 实现了 double write buffer Files, 它位于系统表空间，是一个存储区域。</p><p>在 BufferPool 的 page 页刷新到磁盘真正的位置前，会先将数据存在 Doublewrite 缓冲区。这样在宕机重启时，如果出现数据页损坏，那么在应用 redo log 之前，需要通过该页的副本来还原该页，然后再进行 redo log 重做，double write 实现了 InnoDB 引擎数据页的可靠性.</p><p>默认情况下启用双写缓冲区，如果要禁用 Doublewrite 缓冲区，可以将 <code>innodb_doublewrite</code>设置为 0。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;%innodb_doublewrite%&#39;</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">--------------------+-------+</span>
<span class="token operator">|</span> Variable_name      <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">--------------------+-------+</span>
<span class="token operator">|</span> innodb_doublewrite <span class="token operator">|</span> <span class="token keyword">ON</span>    <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">--------------------+-------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数据双写流程</p><figure><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672133064003/a31680a18f104e0da3f3cb6c1aa71866.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ul><li><strong>step1</strong>：当进行缓冲池中的脏页刷新到磁盘的操作时,并不会直接写磁盘,每次脏页刷新必须要先写 double write .</li><li><strong>step2</strong>：通过 memcpy 函数将脏页复制到内存中的 double write buffer .</li><li><strong>step3</strong>: double write buffer 再分两次、每次 1MB, 顺序写入共享表空间的物理磁盘上, <strong>第一次写</strong>.</li><li><strong>step4</strong>: 在完成 double write 页的写入后，再将 double wirite buffer 中的页写入各个表的<strong>独立表空间</strong>文件中(数据文件 .ibd), <strong>第二次写</strong>。</li></ul><p><strong>为什么写两次 ?</strong></p><p>可能有的同学会有疑问，为啥写两次，刷一次数据文件保存数据不就可以了，为什么还要写共享表空间 ?其实是因为共享表空间是在 ibdbata 文件中划出 2M 连续的空间，专门给 double write 刷脏页用的, 由于在这个过程中，<strong>double write 页的存储是连续的，因此写入磁盘为顺序写，性能很高</strong>；完成 double write 后，再将脏页写入实际的各个表空间文件，这时写入就是离散的了.</p><h3 id="什么是行溢出" tabindex="-1"><a class="header-anchor" href="#什么是行溢出" aria-hidden="true">#</a> 什么是行溢出</h3>`,17),r=[t];function i(l,p){return n(),a("div",null,r)}const u=e(o,[["render",i],["__file","interview5、写失效，行溢出.html.vue"]]);export{u as default};
