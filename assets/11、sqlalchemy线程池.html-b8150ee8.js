const e=JSON.parse('{"key":"v-7d4be784","path":"/posts/%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/11%E3%80%81sqlalchemy%E7%BA%BF%E7%A8%8B%E6%B1%A0.html","title":"11、sqlalchemy线程池","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2024-05-22T00:00:00.000Z","category":["python"],"tag":["sqlalchemy"],"description":"11、sqlalchemy线程池 一、连接池特点 SQLAlchemy连接数据库所使用的Engine对象默认采用一个连接池来管理连接 当我们使用Engine对象所对应的SQL数据库连接的资源时，这些对数据库的连接是通过一个连接池（Connection pooling）来管理的。当我们释放（release）一个连接资源时，这个连接并不是被销毁了，而是仍然连接着数据库，只不过其将会被重新存储如一个用于管理连接的连接池（默认为QueuePool）中。放入连接池中的连接可以被复用。事实上总有一定数目的数据库连接被保存在这个连接池中，即使在我们的代码中看起来像是连接被释放了一样。这些连接会在我们的程序结束运行之后自动被销毁，或者当我们显式地调用销毁连接池的代码时被销毁。 连接复用 由于这个连接池的存在，每当我们在代码中调用Engine.connect()方法或者调用ORM对应的Session的时候，往往会得到一个已存在与连接池中的数据库连接，而不是得到了一个全新的连接对象。然而当连接池中没有现成可用的连接对象的时候，在不超过配置所允许的连接上限的条件下，新的连接对象会被创建并返回给调用这些方法的程序。 默认使用的QueuePool SQLAlchemy默认所使用的连接池为sqlalchemy.pool.QueuePool。当目前总连接数没有超过配置的上限且池中没有现成可用的连接的情况下，一个新的连接会被建立并返回给调用创建新连接的方法的程序。这个上限等于create_engine.pool_size 与create_engine.max_overflow之和。 可上溢的连接池 如果我们将参数create_engine.max_overflow设置为”-1”，那么连接池会允许“上溢”无限多的新连接。在这种情况下，连接池永远不会阻塞一个新的数据库连接请求。相反，每当有新的连接请求且无当前可用的连接对象，连接池就会无条件地创建新的连接对象来返回给这个请求。 然而，即使我们在程序端不限制并发的数据库连接的数目，如果程序无限制的创建新的数据库连接对象，连接的数目最终会到达数据库端的连接数目上限，并且耗尽所有数据库允许的连接，最终同样会造成程序异常。","head":[["meta",{"property":"og:url","content":"https://y-aong.github.io/orderlines_blog/orderlines_blog/posts/%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/11%E3%80%81sqlalchemy%E7%BA%BF%E7%A8%8B%E6%B1%A0.html"}],["meta",{"property":"og:site_name","content":"ORDERLINES"}],["meta",{"property":"og:title","content":"11、sqlalchemy线程池"}],["meta",{"property":"og:description","content":"11、sqlalchemy线程池 一、连接池特点 SQLAlchemy连接数据库所使用的Engine对象默认采用一个连接池来管理连接 当我们使用Engine对象所对应的SQL数据库连接的资源时，这些对数据库的连接是通过一个连接池（Connection pooling）来管理的。当我们释放（release）一个连接资源时，这个连接并不是被销毁了，而是仍然连接着数据库，只不过其将会被重新存储如一个用于管理连接的连接池（默认为QueuePool）中。放入连接池中的连接可以被复用。事实上总有一定数目的数据库连接被保存在这个连接池中，即使在我们的代码中看起来像是连接被释放了一样。这些连接会在我们的程序结束运行之后自动被销毁，或者当我们显式地调用销毁连接池的代码时被销毁。 连接复用 由于这个连接池的存在，每当我们在代码中调用Engine.connect()方法或者调用ORM对应的Session的时候，往往会得到一个已存在与连接池中的数据库连接，而不是得到了一个全新的连接对象。然而当连接池中没有现成可用的连接对象的时候，在不超过配置所允许的连接上限的条件下，新的连接对象会被创建并返回给调用这些方法的程序。 默认使用的QueuePool SQLAlchemy默认所使用的连接池为sqlalchemy.pool.QueuePool。当目前总连接数没有超过配置的上限且池中没有现成可用的连接的情况下，一个新的连接会被建立并返回给调用创建新连接的方法的程序。这个上限等于create_engine.pool_size 与create_engine.max_overflow之和。 可上溢的连接池 如果我们将参数create_engine.max_overflow设置为”-1”，那么连接池会允许“上溢”无限多的新连接。在这种情况下，连接池永远不会阻塞一个新的数据库连接请求。相反，每当有新的连接请求且无当前可用的连接对象，连接池就会无条件地创建新的连接对象来返回给这个请求。 然而，即使我们在程序端不限制并发的数据库连接的数目，如果程序无限制的创建新的数据库连接对象，连接的数目最终会到达数据库端的连接数目上限，并且耗尽所有数据库允许的连接，最终同样会造成程序异常。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-03-17T09:50:53.000Z"}],["meta",{"property":"article:author","content":"Y-aong"}],["meta",{"property":"article:tag","content":"sqlalchemy"}],["meta",{"property":"article:published_time","content":"2024-05-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-17T09:50:53.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"11、sqlalchemy线程池\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-22T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-17T09:50:53.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Y-aong\\",\\"url\\":\\"https://github.com/Y-aong\\"}]}"]]},"headers":[{"level":3,"title":"一、连接池特点","slug":"一、连接池特点","link":"#一、连接池特点","children":[]},{"level":3,"title":"二、不同类型的连接池","slug":"二、不同类型的连接池","link":"#二、不同类型的连接池","children":[]},{"level":3,"title":"三、可用连接被用尽的可能原因","slug":"三、可用连接被用尽的可能原因","link":"#三、可用连接被用尽的可能原因","children":[]}],"git":{"createdTime":1742205053000,"updatedTime":1742205053000,"contributors":[{"name":"Y-aong","email":"1627469727@qq.com","commits":1}]},"readingTime":{"minutes":5.9,"words":1771},"filePathRelative":"posts/模块设计/11、sqlalchemy线程池.md","localizedDate":"May 22, 2024","excerpt":"<h1> 11、sqlalchemy线程池</h1>\\n<h3> 一、连接池特点</h3>\\n<ul>\\n<li>\\n<p><strong>SQLAlchemy连接数据库所使用的Engine对象默认采用一个连接池来管理连接</strong></p>\\n<p>当我们使用Engine对象所对应的SQL数据库连接的资源时，这些对数据库的连接是通过一个连接池（Connection pooling）来管理的。当我们释放（release）一个连接资源时，这个连接并不是被销毁了，而是仍然连接着数据库，只不过其将会被重新存储如一个用于管理连接的连接池（默认为QueuePool）中。放入连接池中的连接可以被复用。事实上总有一定数目的数据库连接被保存在这个连接池中，即使在我们的代码中看起来像是连接被释放了一样。这些连接会在我们的程序结束运行之后自动被销毁，或者当我们显式地调用销毁连接池的代码时被销毁。</p>\\n</li>\\n<li>\\n<p><strong>连接复用</strong></p>\\n<p>由于这个连接池的存在，每当我们在代码中调用Engine.connect()方法或者调用ORM对应的Session的时候，往往会得到一个已存在与连接池中的数据库连接，而不是得到了一个全新的连接对象。然而当连接池中没有现成可用的连接对象的时候，在不超过配置所允许的连接上限的条件下，新的连接对象会被创建并返回给调用这些方法的程序。</p>\\n</li>\\n<li>\\n<p><strong>默认使用的QueuePool</strong><br>\\nSQLAlchemy默认所使用的连接池为sqlalchemy.pool.QueuePool。当目前总连接数没有超过配置的上限且池中没有现成可用的连接的情况下，一个新的连接会被建立并返回给调用创建新连接的方法的程序。这个上限等于<a href=\\"http://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine.params.max_overflow\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>create_engine.pool_size</code></a> 与<a href=\\"http://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine.params.max_overflow\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>create_engine.max_overflow</code></a>之和。</p>\\n</li>\\n<li>\\n<p><strong>可上溢的连接池</strong></p>\\n<p>如果我们将参数<code>create_engine.max_overflow</code>设置为”-1”，那么连接池会允许“上溢”无限多的新连接。在这种情况下，连接池永远不会阻塞一个新的数据库连接请求。相反，每当有新的连接请求且无当前可用的连接对象，连接池就会无条件地创建新的连接对象来返回给这个请求。</p>\\n<p>然而，即使我们在程序端不限制并发的数据库连接的数目，如果程序无限制的创建新的数据库连接对象，连接的数目最终会到达数据库端的连接数目上限，并且耗尽所有数据库允许的连接，最终同样会造成程序异常。</p>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
