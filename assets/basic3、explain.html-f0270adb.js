import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o,c as d,e as t}from"./app-2d0f66e1.js";const c={},r=t('<h1 id="_3、explain执行计划" tabindex="-1"><a class="header-anchor" href="#_3、explain执行计划" aria-hidden="true">#</a> 3、explain执行计划</h1><p>explain 模拟优化器来执行sql查询，分析出查询语句或者是表结构的性能瓶颈</p><figure><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/0ffbda5da5ae491bbf13b13bf75fdbdc.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="一、explain字段的解释" tabindex="-1"><a class="header-anchor" href="#一、explain字段的解释" aria-hidden="true">#</a> 一、explain字段的解释</h3><ul><li><p>id：<code>SELECT</code> 查询的序列标识。当使用 <code>JOIN</code> 查询时，涉及多个 select：</p><ul><li>当 id 相同时，执行顺序 <code>由上向下</code>。</li><li>当 id 不同时，表示包含子查询，id 值会递增。<code>id 值越大，优先级越高，越先执行。</code></li></ul></li><li><p>select type：</p><ul><li><code>SIMPLE</code>：简单查询，不包含 <code>UNION</code> 或者子查询。</li><li><code>PRIMARY</code>：查询中如果包含子查询或其他部分，外层的 <code>SELECT</code> 将被标记为 <code>PRIMARY</code>。</li><li><code>SUBQUERY</code>：子查询中的第一个 <code>SELECT</code>。</li><li><code>UNION</code>：在 <code>UNION</code> 语句中，<code>UNION</code> 之后出现的 <code>SELECT</code>。</li><li><code>DERIVED</code>：在 <code>FROM</code> 中出现的子查询将被标记为 <code>DERIVED</code>。</li><li><code>UNION RESULT</code>：<code>UNION</code> 查询的结果。</li></ul></li><li><p>table: 当前查询执行的数据表。</p></li><li><p>partitions: 查询所匹配记录所在的分区，对于未分区的表，值为 <code>NULL</code>。</p></li><li><p>type:</p><p><code>system</code> &gt; <code>const</code> &gt; <code>eq_ref</code> &gt; <code>ref</code> &gt; <code>fulltext</code> &gt; <code>ref_or_null</code> &gt; <code>index_merge</code> &gt; <code>unique_subquery</code> &gt; <code>index_subquery</code> &gt; <code>range</code> &gt; <code>index</code> &gt; <code>ALL</code></p><ul><li><code>system</code> 表中只有一行数据，是 <code>const</code> 的一种特例。</li><li><code>const</code>表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用<code>主键</code>或<code>唯一索引</code>的所有字段作为查询条件。</li><li><code>eq_ref</code>当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 <code>system</code> 与 <code>const</code> 之外最好的 join 方式，常用于使用<code>主键</code>或<code>唯一索引</code>的所有字段作为连表条件。</li><li><code>ref</code>使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</li><li><code>fulltext</code> 查询使用到了全文索引。</li><li><code>ref_or_null</code>类似于 <code>ref</code>，MySQL 在执行时还查询了值为 <code>NULL</code> 的行。</li><li><code>index_merge</code>当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 <code>key</code> 列列出了使用到的索引；<code>ken_len</code> 列列出了所使用的索引的长度。</li><li><code>unique_subquery</code>替代了 <code>eq_ref</code>。在一些使用 <code>IN</code> 子查询中，使用唯一索引</li><li><code>index_subquery</code> 与 <code>unique_subquery</code> 类似，在 <code>IN</code> 子查询中，使用普通索引</li><li><code>range</code> 对索引列进行范围查询，执行计划中的 <code>key</code> 列表示哪个索引被使用了，<code>key_len</code> 列表示使用的索引的长度。</li><li><code>index</code>查询遍历了整棵索引树，与 <code>ALL</code> 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</li><li><code>ALL</code>查询遍历全表，很可能要读磁盘，速度最慢。</li></ul></li><li><p>possible_keys 列出查询中可能被使用到的一个或多个索引，不一定被查询实际使用。</p></li><li><p>key 查询中实际使用到的索引。如果为 <code>NULL</code>，则表示未建立索引或索引失效。</p></li><li><p>key_len 表示查询索引时使用的字节数，在满足需求的前提下越短越好。</p></li><li><p>ref 表示在查询索引时，哪些列或者常量被用来与索引的值进行比较。</p></li><li><p>rows 展示 MySQL <strong>估算</strong>出的查询时需要遍历的行数，越少越好。</p></li><li><p>filtered 表示估算的经过查询条件删选出的列数的百分比。例如 <code>rows</code> 是 1000，<code>filtered</code> 是 50（50%），则实际筛选出的列数为 1000 * 50% = 500。</p></li><li><p>Extra</p><ul><li><p><code>Using filesort</code>在排序时使用了外部的索引排序，没有用到表内索引进行排序。</p></li><li><p><code>Using temporary</code> MySQL 需要创建临时表来存储查询的结果，常见于 <code>ORDER BY</code> 和 <code>GROUP BY</code>。</p></li><li><p><code>Using index </code>表明查询使用了覆盖索引，不用回表，查询效率非常高。</p></li><li><p><code>Using where </code>表明查询使用了 <code>WHERE</code> 子句进行条件过滤。一般在没有使用到索引的时候会出现。</p></li><li><p><code>Impossible WHERE</code> 表示 <code>WHERE</code> 子句的结果总是 false 且无法查到任意行。</p></li><li><p><code>Using join buffer (Block Nested Loop)</code> 连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 <code>join buffer</code> 中，再遍历被驱动表与驱动表进行查询，具体见 MySQL JOIN 的内容。</p></li><li><p><code>Using join buffer (Batched Key Access) </code>连表查询的方式，与 <code>Using join buffer (Block Nested Loop)</code> 类似。</p></li></ul></li></ul><h3 id="二、type字段" tabindex="-1"><a class="header-anchor" href="#二、type字段" aria-hidden="true">#</a> 二、type字段</h3><p>下面介绍type字段不同值表示的含义:</p><table><thead><tr><th><strong>type类型</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td><strong>system</strong></td><td><strong>不进行磁盘IO,查询系统表,仅仅返回一条数据</strong></td></tr><tr><td><strong>const</strong></td><td><strong>查找主键索引,最多返回1条或0条数据. 属于精确查找</strong></td></tr><tr><td><strong>eq_ref</strong></td><td><strong>查找唯一性索引,返回数据最多一条, 属于精确查找</strong></td></tr><tr><td><strong>ref</strong></td><td><strong>查找非唯一性索引,返回匹配某一条件的多条数据,属于精确查找,数据返回可能是多条.</strong></td></tr><tr><td><strong>range</strong></td><td><strong>查找某个索引的部分索引,只检索给定范围的行,属于范围查找. 比如: &gt; 、 &lt; 、in 、between</strong></td></tr><tr><td><strong>index</strong></td><td><strong>查找所有索引树,比ALL快一些,因为索引文件要比数据文件小.</strong></td></tr><tr><td><strong>ALL</strong></td><td><strong>不使用任何索引,直接进行全表扫描</strong></td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="三、extra主要指标" tabindex="-1"><a class="header-anchor" href="#三、extra主要指标" aria-hidden="true">#</a> 三、Extra主要指标</h3><p>Extra 是 EXPLAIN 输出中另外一个很重要的列，该列显示MySQL在查询过程中的一些详细信息</p><table><thead><tr><th><strong>extra类型</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td><strong>Using filesort</strong></td><td><strong>MySQL中无法利用索引完成的排序操作称为 “文件排序”</strong></td></tr><tr><td><strong>Using index</strong></td><td><strong>表示直接访问索引就能够获取到所需要的数据（覆盖索引），不需要通过索引回表</strong></td></tr><tr><td><strong>Using index condition</strong></td><td><strong>搜索条件中虽然出现了索引列，但是有部分条件无法使用索引，</strong> <strong>会根据能用索引的条件先搜索一遍再匹配无法使用索引的条件。</strong></td></tr><tr><td><strong>Using join buffer</strong></td><td><strong>使用了连接缓存, 会显示join连接查询时,MySQL选择的查询算法</strong></td></tr><tr><td><strong>Using temporary</strong></td><td><strong>表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询</strong></td></tr><tr><td><strong>Using where</strong></td><td><strong>意味着全表扫描或者在查找使用索引的情况下，但是还有查询条件不在索引字段当中</strong></td></tr></tbody></table>',11),i=[r];function n(l,s){return o(),d("div",null,i)}const p=e(c,[["render",n],["__file","basic3、explain.html.vue"]]);export{p as default};
