import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,e}from"./app-2d0f66e1.js";const o={},t=e(`<h1 id="_1、曾经被问到的面试题" tabindex="-1"><a class="header-anchor" href="#_1、曾经被问到的面试题" aria-hidden="true">#</a> 1、曾经被问到的面试题</h1><h3 id="_1、python中的鸭子对象" tabindex="-1"><a class="header-anchor" href="#_1、python中的鸭子对象" aria-hidden="true">#</a> 1、python中的鸭子对象</h3><p>一句话概述，看起来像是鸭子，走路像鸭子，叫声像鸭子他就是鸭子</p><p>对于代码来说，比如可以iter(obj) == True 就是可迭代对象，str, list，没有<code>__next__</code>方法，但是它实现了<code>__getitem__()</code>方法，所以也是可迭代对象</p><h3 id="_2、python3和python2中for-in-xx-xx是什么-为什么要改变" tabindex="-1"><a class="header-anchor" href="#_2、python3和python2中for-in-xx-xx是什么-为什么要改变" aria-hidden="true">#</a> 2、<code>python3</code>和<code>python2</code>中for * in xx,xx是什么，为什么要改变</h3><p><strong>可迭代对象</strong></p><p>具有惰性计算特点的序列称为惰性序列，Python 中的迭代器就是一个惰性序列，调用 iter() 返回一个 iterator 并赋值给一个变量后不会立即进行求值，而是当你用到其中某些元素的时候才去求某元素的值。</p><p>惰性计算还可以在大规模数据处理中平滑处理时间，提高内存使用率。当处理大规模数据时，一次性进行处理往往是不方便的。</p><h3 id="_3、python中的深浅拷贝" tabindex="-1"><a class="header-anchor" href="#_3、python中的深浅拷贝" aria-hidden="true">#</a> 3、python中的深浅拷贝</h3><p>浅拷贝通常只复制对象本身，而深拷贝不仅会复制对象，还会递归的复制对象所关联的对象。深拷贝可能会遇到两个问题：一是一个对象如果直接或间接的引用了自身，会导致无休止的递归拷贝；二是深拷贝可能对原本设计为多个对象共享的数据也进行拷贝。Python通过<code>copy</code>模块中的<code>copy</code>和<code>deepcopy</code>函数来实现浅拷贝和深拷贝操作，其中<code>deepcopy</code>可以通过<code>memo</code>字典来保存已经拷贝过的对象，从而避免刚才所说的自引用递归问题；此外，可以通过<code>copyreg</code>模块的<code>pickle</code>函数来定制指定类型对象的拷贝行为。</p><p><code>deepcopy</code>函数的本质其实就是对象的一次序列化和一次返回序列化，面试题中还考过用自定义函数实现对象的深拷贝操作，显然我们可以使用<code>pickle</code>模块的<code>dumps</code>和<code>loads</code>来做到，代码如下所示。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>import pickle

my_deep_copy = lambda obj: pickle.loads(pickle.dumps(obj))
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>列表的切片操作<code>[:]</code>相当于实现了列表对象的浅拷贝，而字典的<code>copy</code>方法可以实现字典对象的浅拷贝。对象拷贝其实是更为快捷的创建对象的方式。在Python中，通过构造器创建对象属于两阶段构造，首先是分配内存空间，然后是初始化。在创建对象时，我们也可以基于“原型”对象来创建新对象，通过对原型对象的拷贝（复制内存）就完成了对象的创建和初始化，这种做法更加高效，这也就是设计模式中的原型模式。</p><h3 id="_4、正则表达式的match方法和search方法有什么区别" tabindex="-1"><a class="header-anchor" href="#_4、正则表达式的match方法和search方法有什么区别" aria-hidden="true">#</a> 4、正则表达式的match方法和search方法有什么区别？</h3><p><code>match</code>方法是从字符串的起始位置进行正则表达式匹配，返回<code>Match</code>对象或None。<code>search</code>方法会扫描整个字符串来找寻匹配的模式，同样也是返回Match对象或None。</p><h3 id="_5、python中为什么没有函数重载" tabindex="-1"><a class="header-anchor" href="#_5、python中为什么没有函数重载" aria-hidden="true">#</a> 5、Python中为什么没有函数重载</h3><p>首先Python是解释型语言，函数重载现象通常出现在编译型语言中。其次Python是动态类型语言，函数的参数没有类型约束，也就无法根据参数类型来区分重载。再者Python中函数的参数可以有默认值，可以使用可变参数和关键字参数，因此即便没有函数重载，也要可以让一个函数根据调用者传入的参数产生不同的行为。</p><h3 id="_6、python中为什么要引入全局解释器锁" tabindex="-1"><a class="header-anchor" href="#_6、python中为什么要引入全局解释器锁" aria-hidden="true">#</a> 6、python中为什么要引入全局解释器锁</h3><p>Python引入全局解释器锁（GIL，Global Interpreter Lock）的主要原因是为了<strong>简化Python解释器的设计和实现，并确保解释器内部数据结构在多线程环境下的安全性</strong>。<br> GIL是Python解释器中的一种机制，它是一把全局锁，用于<strong>保护解释器免受多线程并发访问的影响</strong>。这意味着在Python中，同一时刻只允许一个线程执行Python字节码。<br> 当一个线程执行Python字节码时，其他线程将被阻塞，即使系统具有多个CPU核心，Python的多线程程序也不能同时利用它们。</p><p>GIL的引入可以追溯到Python的早期设计。在Python的设计初期，为了简化解释器的实现，并确保多线程环境下的线程安全，设计者决定引入GIL。通过GIL，Python解释器不需要在共享数据上实现复杂的同步机制，从而降低了实现的复杂性。然而，GIL的存在也带来了一些限制和挑战。由于GIL的存在，Python的多线程在CPU密集型任务上并不能提供真正的并行性。这意味着在多核CPU上，Python的多线程程序可能无法充分利用硬件资源。</p><p>为了解决这个问题，Python社区已经提出了一些解决方案，如使用多进程（multiprocessing）代替多线程，或者使用支持并行计算的库（如NumPy、SciP等）。</p><p>总之，Python引入GIL是为了简化解释器的设计和实现，并确保多线程环境下的线程安全。然而，这也带来了一些限制和挑战，需要在使用Python多线程时特别注意。</p><h3 id="_7、如何理解异步io" tabindex="-1"><a class="header-anchor" href="#_7、如何理解异步io" aria-hidden="true">#</a> 7、如何理解异步IO</h3><ol><li><strong>同步 vs. 异步</strong>： <ul><li><strong>同步（Synchronous）</strong>：同步操作是指在发起一个操作后，必须等待该操作完成才能继续执行后续的操作。在同步操作中，程序会阻塞（Block）当前线程或进程，直到操作完成。</li><li><strong>异步（Asynchronous）</strong>：异步操作是指在发起一个操作后，可以立即返回并继续执行后续的操作，而不必等待该操作完成。在异步操作中，程序不会阻塞当前线程或进程，而是使用回调函数、事件循环等机制来处理操作的结果。</li></ul></li><li><strong>IO操作</strong>： <ul><li><strong>输入/输出（IO）操作</strong>：指的是与外部设备（例如磁盘、网络等）进行数据交换的操作。在计算机中，IO操作是相对于CPU执行的计算操作而言的。常见的IO操作包括读取文件、发送网络请求、接收网络响应等。</li></ul></li><li><strong>异步IO</strong>： <ul><li><strong>异步IO（Asynchronous IO）</strong>：指的是在进行IO操作时，不需要等待IO操作完成才能继续执行后续的操作。相反，程序可以继续执行其他任务，而IO操作在后台进行。当IO操作完成时，程序可以通过回调函数、事件通知等方式获取IO操作的结果。</li></ul></li></ol><p>在编程中，异步IO通常与事件循环（Event Loop）结合使用，例如在Python中，使用 <code>asyncio</code> 模块来实现异步IO操作。异步IO的优点在<strong>于它可以提高程序的并发性和吞吐量，使程序能够更有效地利用系统资源，从而提高性能</strong>。</p><p>总的来说，理解异步IO就是理解在IO操作时，程序如何以非阻塞的方式继续执行其他任务，并在IO操作完成后获取操作结果的过程。</p><h3 id="_8、异步io和事件循环的关系" tabindex="-1"><a class="header-anchor" href="#_8、异步io和事件循环的关系" aria-hidden="true">#</a> 8、异步IO和事件循环的关系</h3><p>在 Python 中，异步IO和事件循环密切相关，它们通常一起使用来实现异步编程。</p><ol><li><strong>事件循环（Event Loop）</strong>： <ul><li>事件循环是一个在程序中运行的循环，它负责处理和调度异步任务（例如IO操作、定时器等）。</li><li>在事件循环中，任务被添加到事件队列中，并在适当的时候执行。事件循环负责选择要执行的任务，并确保任务按正确的顺序执行。</li><li>Python 中常用的事件循环实现是 <code>asyncio</code> 模块提供的 <code>asyncio.EventLoop</code>。</li></ul></li><li><strong>异步IO（Asynchronous IO）</strong>： <ul><li>异步IO是一种编程模型，它允许程序在执行IO操作时不阻塞当前线程或进程，而是可以继续执行其他任务。</li><li>在Python中，异步IO通常使用 <code>asyncio</code> 模块来实现，它提供了异步编程的基础设施，包括异步IO操作、协程等。</li></ul></li><li><strong>关系</strong>： <ul><li>异步IO依赖于事件循环来调度和执行异步任务。当需要执行一个异步IO操作时，任务会被添加到事件循环的事件队列中，并在事件循环的控制下执行。</li><li>事件循环负责管理异步任务的执行顺序、任务的状态和执行过程中的异常处理等。</li><li>在事件循环中，异步IO操作通常以协程（Coroutine）的形式表示，而协程是一种可以暂停和恢复执行的函数，适用于异步编程。</li></ul></li></ol><p>简而言之，<strong>事件循环是异步IO编程的基础</strong>，它负责调度和执行异步任务，而<strong>异步IO操作则是在事件循环的管理下执行的</strong>。通过事件循环，异步IO可以实现非阻塞的IO操作，并使程序能够更高效地利用系统资源</p><h3 id="_9、-new-方法是什么" tabindex="-1"><a class="header-anchor" href="#_9、-new-方法是什么" aria-hidden="true">#</a> 9、<code>__new__</code> 方法是什么？</h3><p><code>__new__</code> 方法是Python中的一个特殊的静态方法，用于创建类的新实例。它是在<code>__init__</code>方法之前被调用的，并且负责返回类的新实例。<code>__new__</code>方法通常不需要被直接调用，而是由Python解释器在实例化对象时自动调用。</p><p><code>__new__</code>方法的主要作用是创建一个新对象，而<code>__init__</code>方法则用于初始化这个新创建的对象。<code>__new__</code>方法只接收类本身（通常用<code>cls</code>表示）作为第一个参数，后面可以跟任意数量的参数，这些参数将传递给<code>__init__</code>方法。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">:</span>
    _instance <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> cls<span class="token punctuation">.</span>_instance <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            cls<span class="token punctuation">.</span>_instance <span class="token operator">=</span> <span class="token builtin">super</span><span class="token punctuation">(</span>Singleton<span class="token punctuation">,</span> cls<span class="token punctuation">)</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>
        <span class="token keyword">return</span> cls<span class="token punctuation">.</span>_instance

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>  <span class="token comment"># 这里可以初始化实例的属性</span>

<span class="token comment"># 创建Singleton的两个实例</span>
singleton1 <span class="token operator">=</span> Singleton<span class="token punctuation">(</span><span class="token punctuation">)</span>
singleton2 <span class="token operator">=</span> Singleton<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 检查两个实例是否是同一个对象</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>singleton1 <span class="token keyword">is</span> singleton2<span class="token punctuation">)</span>  <span class="token comment"># 输出: True</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>__new__</code>方法通常用于以下情况：</p><ol><li><strong>控制对象的创建</strong>：比如实现单例模式。</li><li><strong>继承不可变类型</strong>：比如<code>int</code>、<code>str</code>、<code>tuple</code>等，因为这些类型的实例是不可变的，所以需要在<code>__new__</code>方法中创建新实例。</li><li><strong>多态实例化</strong>：根据传入的参数动态决定创建哪种类型的对象。</li></ol><p>在大多数情况下，你不需要自定义<code>__new__</code>方法，除非你有特殊的对象创建需求。通常情况下，只需要定义<code>__init__</code>方法来初始化对象即可。</p><h3 id="_10、-init-方法是什么" tabindex="-1"><a class="header-anchor" href="#_10、-init-方法是什么" aria-hidden="true">#</a> 10、<code>__init__ </code>方法是什么？</h3><p><code>__init__</code> 方法是Python中类的构造器，用于在创建类的新实例时初始化对象。当你创建一个新对象时，Python会自动调用<code>__init__</code>方法。这个方法通常用于设置对象的初始状态，比如给对象的属性赋初始值。</p><p><code>__init__</code>方法的第一个参数始终是<code>self</code>，它代表类的实例本身，允许我们访问类的属性和方法。在<code>__init__</code>方法中，你可以定义其他参数来接收初始化数据，并根据这些数据来设置对象的状态。</p><p>如果你不显式定义<code>__init__</code>方法，Python会提供一个默认的<code>__init__</code>方法，这个默认的方法什么也不做。自定义<code>__init__</code>方法可以让你控制对象创建时的行为。</p><h3 id="_11、-new-的作用" tabindex="-1"><a class="header-anchor" href="#_11、-new-的作用" aria-hidden="true">#</a> 11、<code>__new__</code> 的作用</h3><p>依照Python官方文档的说法，__new__方法主要是当你继承一些不可变的class时(比如int, str, tuple)， 提供给你一个自定义这些类的实例化过程的途径。 首先我们来看一下第一个功能，具体我们可以用int来作为一个例子： 假如我们需要一个永远都是正数的整数类型，通过集成int，我们可能会写出这样的代码：</p><p>工厂模式的实现</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Fruit</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>

    <span class="token keyword">def</span> <span class="token function">print_color</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>

<span class="token keyword">class</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span>Fruit<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>

    <span class="token keyword">def</span> <span class="token function">print_color</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;apple is in red&quot;</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Orange</span><span class="token punctuation">(</span>Fruit<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>

    <span class="token keyword">def</span> <span class="token function">print_color</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;orange is in orange&quot;</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">FruitFactory</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    fruits <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;apple&quot;</span><span class="token punctuation">:</span> Apple<span class="token punctuation">,</span> <span class="token string">&quot;orange&quot;</span><span class="token punctuation">:</span> Orange<span class="token punctuation">}</span>

    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> name <span class="token keyword">in</span> cls<span class="token punctuation">.</span>fruits<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> cls<span class="token punctuation">.</span>fruits<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> Fruit<span class="token punctuation">(</span><span class="token punctuation">)</span>

fruit1 <span class="token operator">=</span> FruitFactory<span class="token punctuation">(</span><span class="token string">&quot;apple&quot;</span><span class="token punctuation">)</span>
fruit2 <span class="token operator">=</span> FruitFactory<span class="token punctuation">(</span><span class="token string">&quot;orange&quot;</span><span class="token punctuation">)</span>
fruit1<span class="token punctuation">.</span>print_color<span class="token punctuation">(</span><span class="token punctuation">)</span>    
fruit2<span class="token punctuation">.</span>print_color<span class="token punctuation">(</span><span class="token punctuation">)</span>    
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_13、-init-与-new-的区别" tabindex="-1"><a class="header-anchor" href="#_13、-init-与-new-的区别" aria-hidden="true">#</a> 13、<code>__init__</code>与<code>__new__</code>的区别</h3><p>从上述过程中我们可以发现，这两个方法区别在于：</p><ul><li><p>作用区别，<code>init</code>实例级别，<code>new</code>类级别</p><ul><li>1.<code>__init__</code> 通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。</li><li>2.<code>__new__</code> 通常用于控制生成一个类实例的过程。它是类级别的方法</li></ul></li><li><p>执行顺序，先new 后<code>init</code></p></li></ul>`,48),p=[t];function c(i,l){return s(),a("div",null,p)}const r=n(o,[["render",c],["__file","1、曾经被问到的面试题.html.vue"]]);export{r as default};
