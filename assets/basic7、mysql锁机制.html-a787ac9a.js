import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as n,e as a}from"./app-2d0f66e1.js";const o={},t=a('<h1 id="_7、mysql锁机制" tabindex="-1"><a class="header-anchor" href="#_7、mysql锁机制" aria-hidden="true">#</a> 7、mysql锁机制</h1><h3 id="一、锁的分类" tabindex="-1"><a class="header-anchor" href="#一、锁的分类" aria-hidden="true">#</a> 一、锁的分类</h3><h4 id="_1、不同存储引擎支持不同的锁机制" tabindex="-1"><a class="header-anchor" href="#_1、不同存储引擎支持不同的锁机制" aria-hidden="true">#</a> 1、不同存储引擎支持不同的锁机制</h4><ul><li><strong>MyISAM</strong>和<strong>MEMORY</strong>存储引擎采用的表级锁，</li><li><strong>InnoDB</strong>存储引擎既支持行级锁，也支持表级锁，默认情况下采用行级锁。</li><li><strong>BDB</strong>采用的是页面锁，也支持表级锁</li></ul><h4 id="_2、按照数据操作的类型分" tabindex="-1"><a class="header-anchor" href="#_2、按照数据操作的类型分" aria-hidden="true">#</a> 2、按照数据操作的类型分</h4><ul><li>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。</li><li>写锁（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。</li></ul><h4 id="_3、按照数据操作的粒度分" tabindex="-1"><a class="header-anchor" href="#_3、按照数据操作的粒度分" aria-hidden="true">#</a> 3、按照数据操作的粒度分</h4><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li><li>行级锁： 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li></ul><h4 id="_4、按照操作性能可分为乐观锁和悲观锁" tabindex="-1"><a class="header-anchor" href="#_4、按照操作性能可分为乐观锁和悲观锁" aria-hidden="true">#</a> 4、按照操作性能可分为乐观锁和悲观锁</h4><ul><li><p>乐观锁：一般的实现方式是对记录数据版本进行比对，在数据更新提交的时候才会进行冲突检测，如果发现冲突了，则提示错误信息。</p></li><li><p>悲观锁：在对一条数据修改的时候，为了避免同时被其他人修改，在修改数据之前先锁定，再修改的控制方式。共享锁和排他锁是悲观锁的不同实现，但都属于悲观锁范畴。</p></li></ul><h3 id="二、共享锁和排它锁" tabindex="-1"><a class="header-anchor" href="#二、共享锁和排它锁" aria-hidden="true">#</a> 二、共享锁和排它锁</h3><p>行锁分为共享锁分为共享锁和排它锁</p><p>行锁的是mysql锁中粒度最小的一种锁，因为锁的粒度很小，所以发生资源争抢的概率也最小，并发性能最大，但是也会造成死锁，每次加锁和释放锁的开销也会变大。</p><p><strong>使用MySQL行级锁的两个前提</strong></p><ul><li>使用 innoDB 引擎</li><li>开启事务 (隔离级别为 <code>Repeatable Read</code>)</li></ul><p><strong>InnoDB行锁的类型</strong></p><ul><li><strong>共享锁</strong>（S）：当事务对数据加上共享锁后, 其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。</li><li><strong>排他锁</strong>（X）：如果事务T对数据A加上排他锁后，则其他事务不能再对数据A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。</li></ul><p><strong>加锁的方式</strong></p><ul><li>InnoDB引擎默认更新语句，<strong>update,delete,insert 都会自动给涉及到的数据加上排他锁</strong>，select语句默认不会加任何锁类型，如果要加可以使用下面的方式:</li><li>加共享锁（S）：select * from table_name where ... <strong>lock in share mode</strong>;</li><li>加排他锁（x）：select * from table_name where ... <strong>for update</strong>;</li></ul><p><strong>锁兼容</strong></p><ul><li><p>共享锁只能兼容共享锁, 不兼容排它锁</p></li><li><p>排它锁互斥共享锁和其它排它锁</p></li></ul><h3 id="三、行锁是如何实现" tabindex="-1"><a class="header-anchor" href="#三、行锁是如何实现" aria-hidden="true">#</a> 三、行锁是如何实现</h3><p>I<strong>nnoDB行锁是通过对索引数据页上的记录加锁实现的</strong>，主要实现算法有 3 种：Record Lock、Gap Lock 和 Next-key Lock。</p><ul><li><strong>RecordLock锁：锁定单个行记录的锁。（记录锁，RC、RR隔离级别都支持）</strong></li><li><strong>GapLock锁：间隙锁，锁定索引记录间隙，确保索引记录的间隙不变。（范围锁，RR隔离级别支持）</strong></li><li><strong>Next-key Lock 锁：记录锁和间隙锁组合，同时锁住数据，并且锁住数据前后范围。（记录锁+范围锁，RR隔离级别支持）</strong></li></ul><blockquote><p>注意： InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁</p></blockquote><p><strong>在RR隔离级别，InnoDB对于记录加锁行为都是先采用Next-Key Lock，但是当SQL操作含有唯一索引时，Innodb会对Next-Key Lock进行优化，降级为RecordLock，仅锁住索引本身而非范围。</strong></p><p>各种操作加锁的特点</p><p>1）select ... from 语句：InnoDB引擎采用MVCC机制实现非阻塞读，所以对于普通的select语句，InnoDB不加锁</p><p>2）select ... from lock in share mode语句：追加了共享锁，InnoDB会使用Next-Key Lock锁进行处理，如果扫描发现唯一索引，可以降级为RecordLock锁。</p><p>3）select ... from for update语句：追加了排他锁，InnoDB会使用Next-Key Lock锁进行处理，如果扫描发现唯一索引，可以降级为RecordLock锁。</p><p>4）update ... where 语句：InnoDB会使用Next-Key Lock锁进行处理，如果扫描发现唯一索引，可以降级为RecordLock锁。</p><p>5）delete ... where 语句：InnoDB会使用Next-Key Lock锁进行处理，如果扫描发现唯一索引，可以降级为RecordLock锁。</p><p>6）insert语句：InnoDB会在将要插入的那一行设置一个排他的RecordLock锁。</p><p><strong>下面以“update t1 set name=‘lisi’ where id=10”操作为例，举例子分析下 InnoDB 对不同索引的加锁行为，以RR隔离级别为例。</strong></p><ol><li><p>主键加锁</p><p>加锁行为：仅在id=10的主键索引记录上加X锁。</p><figure><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/beb8ed434aa349e789b59c553a9030bc.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure></li><li><p>唯一键加锁</p><p>加锁行为：现在唯一索引id上加X锁，然后在id=10的主键索引记录上加X锁。</p><figure><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/f0787ff46f15443f9e7d14b8a50ee784.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure></li><li><p>非唯一键加锁</p><p>加锁行为：对满足id=10条件的记录和主键分别加X锁，然后在(6,c)-(10,b)、(10,b)-(10,d)、(10,d)-(11,f)范围分别加Gap Lock。</p></li></ol><figure><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/ea4aeac3a77a45488d8f1227e9f83d05.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="4"><li><p>无索引加锁</p><p>加锁行为：表里所有行和间隙都会加X锁。（当没有索引时，会导致全表锁定，因为InnoDB引擎锁机制是基于索引实现的记录锁定）。</p></li></ol><figure><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/8b90b13b82a44cd9a013596c04f5e3f9.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="四、死锁" tabindex="-1"><a class="header-anchor" href="#四、死锁" aria-hidden="true">#</a> 四、死锁</h3><h4 id="表级死锁" tabindex="-1"><a class="header-anchor" href="#表级死锁" aria-hidden="true">#</a> 表级死锁</h4><p><strong>产生原因</strong></p><p>用户A访问表A（锁住了表A），然后又访问表B；另一个用户B访问表B（锁住了表B），然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。</p><p>用户A--》A表（表锁）--》B表（表锁）</p><p>用户B--》B表（表锁）--》A表（表锁）</p><p><strong>解决方案</strong></p><p>这种死锁比较常见，是由于程序的BUG产生的，除了调整的程序的逻辑没有其它的办法。</p><p>仔细分析程序的逻辑，对于数据库的多表操作时，尽量按照相同的顺序进行处理，尽量避免同时锁定两个资源，如操作A和B两张表时，总是按先A后B的顺序处理， 必须同时锁定两个资源时，要保证在任何时刻都应该按照相同的顺序来锁定资源。</p><h4 id="行级锁死锁" tabindex="-1"><a class="header-anchor" href="#行级锁死锁" aria-hidden="true">#</a> 行级锁死锁</h4><p><strong>产生原因1：</strong></p><p>如果在事务中执行了一条没有索引条件的查询，引发全表扫描，把行级锁上升为全表记录锁定（等价于表级锁），多个这样的事务执行后，就很容易产生死锁和阻塞，最终应用系统会越来越慢，发生阻塞或死锁。</p><p><strong>解决方案1：</strong></p><p>SQL语句中不要使用太复杂的关联多表的查询；使用explain“执行计划&quot;对SQL语句进行分析，对于有全表扫描和全表锁定的SQL语句，建立相应的索引进行优化。</p><p><strong>产生原因2：</strong></p><ul><li><p>两个事务分别想拿到对方持有的锁，互相等待，于是产生死锁</p><figure><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/44213d7bf7b34ccbb340fcf6adb1fb98.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure></li></ul><p><strong>产生原因3</strong>：每个事务只有一个SQL,但是有些情况还是会发生死锁.</p><ol><li>事务1,从name索引出发 , 读到的[hdc, 1], [hdc, 6]均满足条件, 不仅会加name索引上的记录X锁, 而且会加聚簇索引上的记录X锁, 加锁顺序为先[1,hdc,100], 后[6,hdc,10]</li><li>事务2，从pubtime索引出发，[10,6],[100,1]均满足过滤条件，同样也会加聚簇索引上的记录X锁，加锁顺序为[6,hdc,10]，后[1,hdc,100]。</li><li>但是加锁时发现跟事务1的加锁顺序正好相反，两个Session恰好都持有了第一把锁，请求加第二把锁，死锁就发生了。</li></ol><figure><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/02a98ff1858547d79bb11523a6abd225.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p><strong>解决方案:</strong> 如上面的原因2和原因3, 对索引加锁顺序的不一致很可能会导致死锁，所以如果可以，尽量以相同的顺序来访问索引记录和表。在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能；</p>',58),l=[t];function r(s,p){return i(),n("div",null,l)}const d=e(o,[["render",r],["__file","basic7、mysql锁机制.html.vue"]]);export{d as default};
