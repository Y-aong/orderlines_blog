import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as t,e as c}from"./app-2d0f66e1.js";const i={},o=c(`<h1 id="_19、count-列名-、count-1-和-count" tabindex="-1"><a class="header-anchor" href="#_19、count-列名-、count-1-和-count" aria-hidden="true">#</a> 19、count(列名)、count(1)和 count(*)</h1><p><strong>进行统计操作时,count中的统计条件可以三种选择:</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>EXPLAIN  SELECT COUNT(*) FROM user;

EXPLAIN  SELECT COUNT(列名) FROM user;

EXPLAIN  SELECT COUNT(1) FROM user;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="执行效果上" tabindex="-1"><a class="header-anchor" href="#执行效果上" aria-hidden="true">#</a> 执行效果上：</h3><ul><li><p>count(*) 包括了所有的列,在统计时 不会忽略列值为null的数据。</p></li><li><p>count(1) 用1表示代码行,在统计时,不会忽略列值为null的数据。</p></li><li><p>count(列名)在统计时,会忽略列值为空的数据,就是说某个字段的值为null时不统计。</p></li></ul><h3 id="执行效率上" tabindex="-1"><a class="header-anchor" href="#执行效率上" aria-hidden="true">#</a> 执行效率上：</h3><ul><li>InnoDB引擎：count（字段) &lt; count(1) = count(*) <ul><li>InnoDB通过遍历最小的可用二级索引来处理select count(*) 语句，除非索引或优化器提示指示优化器使用不同的索引。如果二级索引不存在，则通过扫描聚集索引来处理。</li><li>InnoDB已同样的方式处理count(1)和count(*)</li></ul></li><li>MyISAM引擎：count（字段) &lt; count(1) &lt;= count(*) <ul><li>MyISAM存储了数据的准确行数，使用 <code>count(*)</code>会直接读取该行数， 只有当第一列定义为NOT NULL时，count（1），才会执行该操作，所以优先选择 <code>count(*)</code></li></ul></li><li>count(列名) 会遍历整个表，但不同的是，它会先获取列，然后判断是否为空，然后累加，因此count(列名)性能不如前两者。</li><li></li></ul><h3 id="注意" tabindex="-1"><a class="header-anchor" href="#注意" aria-hidden="true">#</a> 注意：</h3><p>count(*)，这是SQL92 定义的标准统计行数的语法，跟数据库无关，与NULL也无关。而count(列名) 是统计列值数量，不计NULL，相同列值算一个。</p>`,9),l=[o];function u(a,r){return e(),t("div",null,l)}const _=n(i,[["render",u],["__file","interview8、count(列名)，count(1)，count()区别.html.vue"]]);export{_ as default};
