import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as c,c as i,a as n,b as s,d as e,e as t}from"./app-2d0f66e1.js";const l={},u=n("h1",{id:"最长递增子序列",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#最长递增子序列","aria-hidden":"true"},"#"),s(" 最长递增子序列")],-1),d={id:"_300-最长递增子序列",tabindex:"-1"},r=n("a",{class:"header-anchor",href:"#_300-最长递增子序列","aria-hidden":"true"},"#",-1),k={href:"https://leetcode.cn/problems/longest-increasing-subsequence/",target:"_blank",rel:"noopener noreferrer"},m=t(`<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>示例 1：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：nums = [0,1,0,3,2,3]
输出：4
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：nums = [7,7,7,7,7,7,7]
输出：1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong></p><ul><li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li></ul><p>思路：</p><p>动态规划：</p><p>遇到子序列，子数组，子串问题的第一个思路就是，从左到右遍历。</p><p>假设数组为<code>[1,3,2,4,6,7]</code>其中最长递增子序列为<code>[1,2,4,6,7]</code>当遍历到4时我们需要得到前面数组的信息，比如j=2,如果nums[3]&gt;nums[2],以3结尾的数组的最长子序列要加一</p><p>按照动态规划五部曲</p><p>第一步定义dp数组含义</p><ul><li>dp[i]的值代表<code>nums</code>以<em>n<strong>u</strong>m**s</em>[<em>i</em>]结尾的最长子序列长度</li><li>初始化参数，每个数都可以是子数组长度为1的最长子序列，所以初始化为1</li><li>确定遍历顺序：前面说了从左到右</li><li>递归方程：num[i]&gt;num[j],dp[i] = max(dp[j] + 1, dp[i])</li><li>打印dp数组</li></ul><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token comment"># print(dp)</span>
        <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>二分法：</p><p>由于获取到j要遍历0-i之间的所有数，所以可以省略这一步吗。</p><p>答案是可以的，定义一个数组来接住递增数组的每一个元素就可以了。</p><p>定义个<code>tail</code> 数组，用于保存当前找到的LIS中的最小可能尾部值，保证这个数组是连续递增的</p><p><code>bisect_left</code> 函数用来查找 <code>nums[i]</code> 在 <code>tail</code> 中应插入的位置，从而保证 <code>tail</code> 数组始终是有序的。</p><p>如果 <code>nums[i]</code> 大于 <code>tail</code> 数组中的所有元素，则它将扩展当前的LIS；否则，它会替换掉 <code>tail</code> 中比它大的第一个元素，这样可以确保后续的数字有更小的目标去匹配，有助于形成更长的递增子序列。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> bisect

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token comment"># 初始化一个长度与nums相同，但是所有元素都是正无穷大的列表。</span>
        tail <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">&#39;inf&#39;</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        ans <span class="token operator">=</span> <span class="token number">0</span>
        
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 使用二分查找找到nums[i]在tail中的位置</span>
            index <span class="token operator">=</span> bisect<span class="token punctuation">.</span>bisect_left<span class="token punctuation">(</span>tail<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            
            <span class="token comment"># 更新该位置的值为nums[i]</span>
            tail<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        
        <span class="token comment"># 计算tail中实际包含的有效元素数量（即不为正无穷大的元素数量）</span>
        <span class="token keyword">for</span> num <span class="token keyword">in</span> tail<span class="token punctuation">:</span>
            <span class="token keyword">if</span> num <span class="token operator">!=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">&#39;inf&#39;</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                ans <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">break</span>
        
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,27),v={id:"_673-最长递增子序列的个数",tabindex:"-1"},b=n("a",{class:"header-anchor",href:"#_673-最长递增子序列的个数","aria-hidden":"true"},"#",-1),g={href:"https://leetcode.cn/problems/number-of-longest-increasing-subsequence/",target:"_blank",rel:"noopener noreferrer"},h=t(`<p>给定一个未排序的整数数组 <code>nums</code> ， <em>返回最长递增子序列的个数</em> 。</p><p><strong>注意</strong> 这个数列必须是 <strong>严格</strong> 递增的。</p><p><strong>示例 1:</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2:</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入: [2,2,2,2,2]
输出: 5
解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2000</code></li><li><code>-106 &lt;= nums[i] &lt;= 106</code></li></ul><p>思路：</p><p><code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的最长递增子序列的长度，<code>count[i]</code> 表示这些子序列的数量。</p><ul><li>当 <code>dp[j] + 1 &gt; dp[i]</code> 时，这意味着通过将 <code>nums[i]</code> 添加到以 <code>nums[j]</code> 结尾的递增子序列中，可以获得一个比当前以 <code>nums[i]</code> 结尾的最长递增子序列还要长的新序列。因此，你需要更新 <code>dp[i]</code> 为 <code>dp[j] + 1</code>，同时将 <code>count[i]</code> 更新为 <code>count[j]</code>，因为现在 <code>nums[i]</code> 的最长递增子序列数量与 <code>nums[j]</code> 的相同。</li><li>当 <code>dp[j] + 1 == dp[i]</code> 时，这表示可以通过添加 <code>nums[i]</code> 到以 <code>nums[j]</code> 结尾的递增子序列来获得与当前以 <code>nums[i]</code> 结尾的最长递增子序列一样长的新序列。这意味着存在多条路径到达相同的最长递增子序列长度。因此，你需要将 <code>count[j]</code> 加到 <code>count[i]</code> 上，以累计所有可能的路径数。</li></ul><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findNumberOfLIS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        count <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>
                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
                        count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                    <span class="token keyword">elif</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
                        count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> count<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
        max_size <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span>
        ans <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> max_size<span class="token punctuation">:</span>
                ans <span class="token operator">+=</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,12),_={id:"_354-俄罗斯套娃信封问题",tabindex:"-1"},f=n("a",{class:"header-anchor",href:"#_354-俄罗斯套娃信封问题","aria-hidden":"true"},"#",-1),y={href:"https://leetcode.cn/problems/russian-doll-envelopes/",target:"_blank",rel:"noopener noreferrer"},x=t(`<p>给你一个二维整数数组 <code>envelopes</code> ，其中 <code>envelopes[i] = [wi, hi]</code> ，表示第 <code>i</code> 个信封的宽度和高度。</p><p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算 <strong>最多能有多少个</strong> 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p><strong>注意</strong>：不允许旋转信封。</p><p><strong>示例 1：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出：3
解释：最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：envelopes = [[1,1],[1,1],[1,1]]
输出：1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>1 &lt;= envelopes.length &lt;= 105</code></li><li><code>envelopes[i].length == 2</code></li><li><code>1 &lt;= wi, hi &lt;= 105</code></li></ul><p>思路：</p><p>和上题连续递增子序列完全一致，当时我在做就是在纠结信封的宽度一致如何处理，其实只需要将高度递减就可以避免同宽的情况了，因为它先被选中了，后续的就不会被再次选中了</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxEnvelopes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> envelopes<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token comment"># 降序保证在同宽里高是最大的, 先被选择</span>
        envelopes <span class="token operator">=</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>envelopes<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> obj<span class="token punctuation">:</span> <span class="token punctuation">(</span>obj<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token operator">-</span>obj<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        tails <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">&#39;inf&#39;</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>envelopes<span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>envelopes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            index <span class="token operator">=</span> bisect<span class="token punctuation">.</span>bisect_left<span class="token punctuation">(</span>tails<span class="token punctuation">,</span> envelopes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            tails<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> envelopes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>

        ans <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> temp <span class="token keyword">in</span> tails<span class="token punctuation">:</span>
            <span class="token keyword">if</span> temp <span class="token operator">==</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">&#39;inf&#39;</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">break</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                ans <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,13);function w(j,L){const a=o("ExternalLinkIcon");return c(),i("div",null,[u,n("h3",d,[r,s(),n("a",k,[s("300. 最长递增子序列"),e(a)])]),m,n("h3",v,[b,s(),n("a",g,[s("673. 最长递增子序列的个数"),e(a)])]),h,n("h3",_,[f,s(),n("a",y,[s("354. 俄罗斯套娃信封问题"),e(a)])]),x])}const N=p(l,[["render",w],["__file","3、最长递增子序列.html.vue"]]);export{N as default};
